---
tags:
  - leetcode
  - recipes
---
## Описание

Этот рецепт описывает алгоритм по циклическому удалению определённых подстрок из строки. К примеру, подстроки, где `2` буквы повторяются, или подстроки, где одна буква в верхнем регистре, а вторая в нижнем и т.д.. Циклически означает то, что в конечном варианте не остается подстрок, которые могли бы удовлетворять условию.

Рассмотрим решение для одного из таких условий.

Дается строка `s`, нужно вернуть новую строку, где все подстроки с повторяющемся символами длиной `2` будут удалены. То есть строка `abbaca` после удаления сначала превратится `aaca`, а затем в `ca` ([[1047]]).

Как пример цикличности можно привести игру `Zuma`, где при уничтожении последовательности шаров из одного цвета, если перед и после этой последовательности были шары одинакового цвета и вместе их количество было равно `3`, то они также уничтожаются и так до тех пор, пока это условие не будет ложным.

TODO: Разработать приложения на подобие зума:

1. Со стеком;
2. С двусвязным списком;
3. С хеш-таблицей, хранить ссылки на начало последовательности узлов и индексы.

![[Циклическое-удаление-подстрок_1.png]]

---
## Вариант 1

Одно из решений заключается в созданию двух циклов. Внутренний цикл создают новую строку, где убираются все подстроки, который подпадают под условия. А внешний цикл выполняется до тех пор, пока нужные подстроки в строке существуют.

Это решение занимает `O(n^2)` по времени и `O(n)` по памяти, из-за времени в большинстве случаев такое решение тесты не пропустят. Здесь оно приведено для примера.

```typescript
const removeDuplicates = (s: string): string => {
  let output = s;
  let temp = '';
  let duplicateWasMet = true;

  for (;duplicateWasMet;) {
    duplicateWasMet = false;

    for (let i = 0; i < output.length;) {
      if (output[i] === output[i + 1]) {
        duplicateWasMet = true;

        i += 2;
      } else {
        temp += output[i];

        i += 1;
      }
    }

    output = temp;
    temp = '';
  }

  return output;
};
```

---
## Вариант 2

Можно использовать `стек`, если на его вершине буква отличается от текущей, то заносим буквы в `стек`, иначе удаляем её от туда. Итого в `стеке` остаются буквы, чьих дубликатов нет.

Это решение занимает `O(n)` по времени и `O(n)` по памяти, но оно не подходит для тех случаев, когда длина подстроки, которая должна быть удалена будет больше `2`. Для решение с более длинными подстроками подойдет [[Циклическое удаление подстрок#Вариант 2.1|Вариант 2.1]].

```typescript
const removeDuplicates = (s: string): string => {
  const stack = [];

  for (const letter of s) {
    if (stack.at(-1) === letter) {
      stack.pop();
    } else {
      stack.push(letter);
    }
  }

  const output = [];

  for (;stack.length !== 0;) {
    output.push(stack.pop());
  }

  return output.reverse().join('');
};
```

---
### Вариант 2.1

Для более сложных условий и длинных подстрок алгоритмы могут отличаться. Но использование `стека` все ещё возможно. К примеру, задача [[1209]], где нужно удалить подстроку из символов, чья длина равна `k` и все символы в этой подстроке повторяются.

В `стеке` нужно хранить не число, а пару `[буква, частота её встречаемости]`. Если текущая буква есть на вершине `стека`, то просто обновляем её частоту, иначе кладём пару на вершину `стека`. Если при обновлении её частота стала равной `k`, то удаляем эту пару из `стека`.

```typescript
const removeDuplicates = (s: string, k: number): string => {
  const stack = [];

  for (const letter of s) {
    const top = stack.at(-1) ?? [];

    if (top[0] === letter) {
      top[1] += 1;

      if (top[1] === k) {
        stack.pop();
      }
    } else {
      stack.push([letter, 1]);
    }
  }

  const output = [];

  for (;stack.length !== 0;) {
    const pair = stack.pop();

    output.push(pair[0].repeat(pair[1]));
  }

  return output.reverse().join('');
};
```

---
## Вариант 3

Здесь используется техника [[Два указателя]].

`i` - позиция в массиве, куда будет поставлен элемент из позиции `j`.
`j` - позиция текущего элемента в массиве.

Если `condition === true`, это значит, что последние два элемента, начиная с `j` одинаковые, и их нужно удалить. Это делается через перемещение `i` на позицию перед дубликатами (`i -= 2`). Затем счетчики возрастут на `1` и на позиции, где раньше был дубликат появится новая буква и так до тех пор, пока все `j` не выйдет за пределы массива.

После цикла все буквы до `i` будут теми, для которых дубликаты не были найдены.

Для примера, возьмем строку `abba`. После того как `i` будет находиться на индексе `2` и `j` на `2`, выполнится условие `output[j] === output[i - 1]`, что означает дубликат был найден (`b`), поэтому перемещаем `i` на позицию до дубликата, то есть `0`. Далее `i` будет иметь позицию `1`, а `j` `3`, снова выполнится условие, дубликат найден (`a`), поэтому перемещаем `i` на позицию до дубликата `-1`. В конце итерации `i` и `j` увеличиваются на `1`, поэтому `i` станет равным `0`.

Это решение занимает `O(n)` по времени и `O(n)` по памяти, а изменяя `condition` и число, которое отнимается от `i` можно регулировать подстроку, которая должна быть удалена.

> Это решение приведено, чтобы показать, что можно сделать такой ряд задач и без `стека`, но `стек` более понятен, поэтому рекомендуется использовать его, если условие не требует обратного.

```typescript
const removeDuplicates = (s: string): string => {
  const output = s.split('');

  let i = 0;

  for (let j = 0; j < s.length; j += 1, i += 1) {
    const condition = output[j] === output[i - 1];

    if (condition) {
      i -= 2;
    } else {
      output[i] = output[j];
    }
  }

  return output.slice(0, i).join('');
};
```

---
## Задачи, с применением рецепта

```dataviewjs
const { utils } = require(app.vault.adapter.basePath + "/Files/JS/dataviewUtils.js");

const {
  renderTasksTable,
} = utils;

renderTasksTable(dv, ["Tasks", "Level", "Recommended", "Topics"]);
```