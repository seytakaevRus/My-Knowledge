---
tags:
  - leetcode
  - recipes
---
## Описание

Здесь описан рецепт перебора двух массивов/строк поэлементно, но может применяться и для большего количества массивов.

Есть строка `word1` и строка `word2`, нужно создать новую строку `output`, куда сначала помещается одна буква из `word1`, затем буква из `word2`, потом снова буква из `word1` и т.д. Если одна строк заканчивается раньше, то буквы из другой строки просто переносятся в `output` ([[1768]]).

Сначала заводятся указатели на первый и второй массив ([[Два указателя]]). Затем объявляется цикл с условием, как показано в вариантах ниже.

TODO: Прорешать больше задача на эту тему.
TODO: Перевести эту в техники

---
## Вариант 1

Здесь объявляется условие `продолжать, пока не переберем все элементы из двух массивов`. В зависимости от условия выбираем элемент из первого или второго массива, а если элементы закончились в одном массиве, то берем оставшиеся элементы из второго.

Встречаются задачи, где элементы нужно сравнивать между собой, и если один из массивов уже закончился, а во втором элементы ещё остались, то можно значение несуществующих элементов вместо `undefined` делать максимальным/минимальным значением, исходя из ограничений, как в задаче [[21]].

```typescript
const mergeAlternately = (word1: string, word2: string): string => {
  let output = '';
  let word1Pointer = 0;
  let word2Pointer = 0;

  for (;word1Pointer < word1.length || word2Pointer < word2.length;) {
    if (word1Pointer < word1.length) {
      output += word1[word1Pointer];

      word1Pointer += 1;
    }

    if (word2Pointer < word2.length) {
      output += word2[word2Pointer];

      word2Pointer += 1;
    }
  }

  return output;
};
```

---
## Вариант 2

Здесь же условие `продолжать, пока пока в одном массиве не закончатся указатели`. В таком случае после основного цикла нужно будет использовать два дополнительных цикла, которые будут вытаскивать оставшиеся элементы либо из первого массива, либо из второго массива. Либо управление до этих циклов не дойдет, так как длина первого массива равна длине второго массива.

```typescript
const mergeAlternately = (word1: string, word2: string): string => {
  let output = '';
  let word1Pointer = 0;
  let word2Pointer = 0;

  for (;word1Pointer < word1.length && word2Pointer < word2.length;) {
    output += word1[word1Pointer];

    word1Pointer += 1;

    output += word2[word2Pointer];

    word2Pointer += 1;
  }

  for (;word1Pointer < word1.length;) {
    output += word1[word1Pointer];

    word1Pointer += 1;
  }

  for (;word2Pointer < word2.length;) {
    output += word2[word2Pointer];

    word2Pointer += 1;
  }

  return output;
};
```

---
## Вариант 3

Иногда не нужно проходить до конца по двум массивам, тогда можно использовать [[Перебор двух массивов поэлементно#Вариант 2|Вариант 2]] но без доп. циклов.

Как в [[349]] задаче.
