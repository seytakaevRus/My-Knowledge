---
tags:
  - leetcode
  - recipes
---
## Описание

Здесь описан рецепт перебора двух массивов/строк поэлементно, но может применяться и для большего количества массивов.

Есть строка `word1` и строка `word2`, нужно создать новую строку `output`, куда сначала помещается одна буква из `word1`, затем буква из `word2`, потом снова буква из `word1` и т.д. Если одна строк заканчивается раньше, то буквы из другой строки просто переносятся в `output` ([[1768]]).

Сначала заводятся указатели на первый и второй массив ([[Два указателя]]). Затем объявляется цикл с условием, как показано в вариантах ниже.

---
## Вариант 1

Здесь объявляется условие `продолжать пока оба указатели не станут больше длин соотетствующих массивов`. К примеру, если `word1.length < word2.length`, то когда `word1Pointer` станет больше `word1.length`, в `output` будут добавляться символы из `word2`.

```typescript
const mergeAlternately = (word1: string, word2: string): string => {
  let output = '';
  let word1Pointer = 0;
  let word2Pointer = 0;

  for (;word1Pointer < word1.length || word2Pointer < word2.length;) {
    if (word1Pointer < word1.length) {
      output += word1[word1Pointer];

      word1Pointer += 1;
    }

    if (word2Pointer < word2.length) {
      output += word2[word2Pointer];

      word2Pointer += 1;
    }
  }

  return output;
};
```

---
## Вариант 2

Здесь же условие `продолжать пока один из указателей не станет больше, чем длина соответствующего массив`. В таком случае после основного цикла нужно будет использовать два дополнительных, которые будут вытаскивать оставшиеся буквы либо из `word1`, либо из `word2`, либо основной цикл будет последним, потому что `word1.length === word2.length`.

```typescript
const mergeAlternately = (word1: string, word2: string): string => {
  let output = '';
  let word1Pointer = 0;
  let word2Pointer = 0;

  for (;word1Pointer < word1.length && word2Pointer < word2.length;) {
    output += word1[word1Pointer];

    word1Pointer += 1;

    output += word2[word2Pointer];

    word2Pointer += 1;
  }

  for (;word1Pointer < word1.length;) {
    output += word1[word1Pointer];

    word1Pointer += 1;
  }

  for (;word2Pointer < word2.length;) {
    output += word2[word2Pointer];

    word2Pointer += 1;
  }

  return output;
};
```

---
## Вариант 3

Иногда не нужно проходить до конца по двум массивам, тогда можно использовать `Вариант 2`, но без доп. циклов.

Как в [[349]] задаче.
