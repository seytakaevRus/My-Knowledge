---
tags:
  - leetcode
  - recipes
---
## Описание

Здесь описывается рецепт нахождения `n-ого` максимума или минимума. 

К примеру, есть массив `[1,5,4,5]` нужно найти третий максимум. Стоит уточнить, что максимумы здесь представляют собой числа на разных индексах. Первый и второй максимум будут равны между собой по значениям, но их индексы будут различны.

---
## Вариант 1

Самый простой способ заключается в сортировке массива и вытаскиванию из него нужного по порядку числа.

Такой способ занимает `O(n log n)` по скорости и `O(log n)` по памяти.

```typescript
const findThirdMax = (nums: number[]): number => {
  nums.sort((a, b) => b - a);

  return nums[2];
};
```

---
## Вариант 2

Другой способ заключается в том, чтобы хранить значения предыдущих максимумов. Максимум любого порядка будет обновляться в следующих случаях:

1. Текущее значение больше, чем максимум;
2. Максимум более высокого порядка был изменён (если изменён максимум первого порядка, то нужно соответственно обновить максимумы второго и третьего порядка, изменён максимум второго порядка, нужно обновить максимум третьего).

Изначально максимум равен `-Inifinity`, потому что любое значение в массиве будет больше этого изначального максимума.

Такой способ занимает `O(n)` по времени и `O(1)` по памяти.

```typescript
const thirdMax = (nums: number[]): number => {
  let max = -Infinity;
  let secondMax = -Infinity;
  let thirdMax = -Infinity;

  for (const value of nums) {
    if (value === max || value === secondMax || value === thirdMax) continue;

    if (value > max) {
      thirdMax = secondMax;
      secondMax = max;
      max = value;
    } else if (value > secondMax) {
      thirdMax = secondMax;
      secondMax = value;
    } else if (value > thirdMax) {
      thirdMax = value;
    }
  }

  return thirdMax === -Infinity ? max : thirdMax;
};
```