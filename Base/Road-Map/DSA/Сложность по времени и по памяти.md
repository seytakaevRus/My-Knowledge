---
tags:
  - draft
  - roadmap
refs:
  - https://zerotomastery.io/courses/learn-data-structures-and-algorithms/
date: 2024-04-11
author: Ruslan Seit-Akaev
---
## Big O

`O(...)` - используется для описания того, насколько возрастает количество операций при увеличении количества входных параметров. Обычно применяется для сравнения эффективности между алгоритмами.

Также `O(...)` может использоваться для оценки сложности по памяти. Рассчитывается память, которая была использована во время выполнения алгоритма. Выделение памяти под параметры функции не учитываются.

## Правила для подсчета сложности

### Худший сценарий

При подсчете `O(...)` всегда следует думать о худшем сценарии. К примеру, если мы ищем элемент в массиве, то худший сценарий тот, где элемент находится в самом конце массива, поэтому перебор массива занимает `O(n)`.
### Удаление констант

При подсчете `O(...)` важно лишь примерная оценка, константы могут быть отброшены.

`O(2)` превратится в `O(1)`.
`O(2n)` превратится в `O(n)`.
`O(n + 50000000000000000)` превратится в `O(n)`.
### Для разных входных данных, разное обозначение

Если нужно пройтись сначала по массиву `array1`, а потом по массиву `array2`, то сложность это алгоритма составляет `O(n + m)`, где `n` - сложность прохождения по массиву `array1`, а `m` - сложность прохождения по массиву `array2`.

А если нужно пройти по массиву `array1` и каждый его элемент сравнить со всеми элементами из массива `array2`, то такая сложность уже составит `O(n * m)`.

### Отбрасывать меньшие показатели

При подсчете `O(...)` важно лишь примерная оценка, меньшие показатели могут быть отброшены.

`O(2n + n^2 + n)` превратится в `O(n^2)`, так как `n` и `2n` меньше, чем `n^2`.
## O(1)

### По времени

Сложность алгоритма по времени `O(1)`, если размер передаваемых данных не влияет на производительность.

Время выполнения функции ниже не зависит от количества данных, которое в неё будет передаваться.

```typescript
const sayHello = (args) => {
  console.log('hello');
}
```

### По памяти

Сложность алгоритма по памяти `O(1)`, если размер передаваемых данных не влияет на выделение дополнительной памяти во время выполнения алгоритма.

В коде ниже только выделяется память под переменную `i`, нет дополнительных структур размер которых увеличивался с количеством входных данных.

```typescript
const iterateCycle = (nums) => {
  for (let i = 0; i < nums.length; i++) {
    console.log(nums[i]);
  }
}
```
## O(n)

### По времени

Сложность алгоритма по времени `O(n)`, если размер передаваемых данных линейно влияет на производительность.

В коде ниже осуществляется проход по массиву с использованием цикла, количество операций в цикле линейно зависят от размера массива, если массив будет из 5 элементов, то и цикл выполнится 5 раз, поэтому время выполнения будет `O(n)`.

```typescript
const nums = [1, 2, 3, 4, 5];

for (let i = 0; i < nums.length; i++) {
  console.log(nums[i]);
}
```

Здесь два цикла, который проходятся по разным массивам, поэтому можно сказать, что сложность будет `O(n + m)`, где `n` - длина массива `nums`, а `k` - длина массива `strings`. Но так как нас интересует примерная оценка, то можно упростить до `O(n)`.

```typescript
const nums = [1, 2, 3, 4, 5];
const strings = ['a', 'b', 'c', 'd', 'f'];

for (let i = 0; i < nums.length; i++) {
  console.log(nums[i]);
}

for (let i = 0; i < strings.length; i++) {
  console.log(nums[i]);
}
```

### По памяти

Сложность алгоритма по памяти `O(n)`, если размер передаваемых данных линейно влияет на количество дополнительной памяти, которое выделяется при выполнении алгоритма.

В коде ниже дополнительная память выделяется под переменную `out`, если `nums` будет длиной в 10 элементов, то и `out` будет в 10 элементов, поэтому сложность `O(n)`.
 
```typescript
const iterateCycle = (nums) => {
  const out = [];

  for (let i = 0; i < nums.length; i++) {
    out.push(nums[i]);
  }
}
```
## O(n^2)

### По времени

Сложность алгоритма по времени `O(n^2)`, если размер передаваемых данных квадратично влияет на производительность.

В коде ниже присутствуют два цикла, оба из них выполняются за `O(n)`, поэтому и сложность такого алгоритма `O(n*n)` или `O(n^2)`, если бы внутри был ещё один цикл, то сложность возросла бы до `O(n^3)`.

```typescript
const numbers = [1, 2, 3, 4, 5];

for (let i = 0; i < numbers.length; i++) {
	for (let j = 0; j < numbers.length; j++) {
	  console.log(`${i}, ${j}`);
	}
}
```
## O(log n)

### По времени

Сложность алгоритма по времени `O(log n)`, если размер передаваемых данных логарифмически влияет на производительность, за основание обычно берется логарифм с основанием `10`.

Примером такого алгоритма может быть `бинарный поиск`, где на каждой итерации отсекается около половины элементов.
## O(2^n)

### По времени

Сложность алгоритма по времени `O(2^n)`, если размер передаваемых данных экспоненциально влияет на производительность алгоритма.

```typescript
const fibonacci = (n) => {
  if (n === 0) return 0;
  if (n === 1) return 1;
    
  return fibonacci(n-1) + fibonacci(n-2);
}
```

![[DSA_1.png]]
## При подсчете сложности по времени учитывать

Циклы и вызовы функций. К примеру, если функция выполняется за `O(n)` и эта функция находится в цикле, то такой код оценивается, как `O(n^2)`.
## При подсчете сложности по памяти учитывать

Объявление переменных и дальнейшие их изменение в коде, к примеру, объявление массива и на каждой итерации цикла добавление элемента в массив будет стоить `O(n)`.

Использование структур данных и алгоритмов, к примеру, одна сортировка может стоить меньше памяти, чем другая.

Вызовы функций, вызов хранится в стеке вызовов, а значит тоже занимает какую-то память.