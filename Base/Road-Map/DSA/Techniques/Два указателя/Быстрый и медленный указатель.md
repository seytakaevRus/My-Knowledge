---
tags:
  - leetcode
  - technique
---
## Описание

`Техника быстрого и медленного` указателя, известная также `алгоритм Черепахи и Зайца`, это алгоритм с указателями, который использует два указателя, чтобы пройтись по `массиву` (или последовательности/`связному списку`), причем каждый из указателей идет с разной скоростью. Эта техника полезна, когда имеешь дело с `циклическими связными списками` или `массивами`.

При работе с этой техникой, я обнаружил две её разновидности, одной из них является `быстрый и медленный указатель`, а второй `лидирующий и отстающий указатель`. Вторая разновидность может использоваться в разрыве от первой, поэтому я их и разделил.

### Быстрый и медленный

Одной из популярных проблем, которую решает эта разновидность, является "Определить имеет ли связный список цикл". 

Если перемещать два указателя, один из которых проходит `1` узел за раз (`медленный`), а второй проходит `2` узла за раз (`быстрый`), то может быть две ситуации:

- быстрый указатель дойдет до конца структуры данных, это означает, что цикла в структуре нет;
- быстрый указатель догонит медленный, это будет означать, что цикл есть, причем гарантированно, что при использовании этой техники быстрый догонит медленного.

Доказательство того, что быстрый указатель догонит медленный, состоит в том, что за раз расстояние будет между ними уменьшатся на `2 - 1 = 1`.

Если увеличить скорость быстрого указателя, к примеру, сделать `3`,  `4` или больше узлов за раз, то встреча двух указателей  будет гарантирована, только это может занять больше итераций.

### Лидирующий и отстающий

Это разновидность решает проблему "Определить узел в связном списке, на котором начинается цикл".

Для этого, сначала нужно, чтобы указатели встретились на каком-то узле. Далее `медленный указатель` помещается на начало связного списка и становится `отстающим указателем`, а `быстрый указатель` остается на том узле, где они встретились и становится `лидирующим`. Теперь указатели нужно перемещать со скоростью `1` узел за раз, и узел, где они встретятся будет являться началом цикла.
#### Доказательство

![[DSA_Медленный-и-быстрый-указатель_1.png]]

`x` - расстояние между `head` и точкой начала цикла;
`y` - расстояние между точкой начала цикла и первой встречей двух указателей;
`z` - оставшееся расстояние от длины цикла минус `y`.

При условиях, что быстрый указатель перемещается за `2` узла за раз, а медленный за `1` узел за раз, следует:

1. расстояние, которое пройдет медленный узел будет равно `x + y`;
2. расстояние, которое пройдет быстрый узел будет равно `x + y + z + y`;
3. так как скорость быстрого в `2` раза больше, то `2 * (x + y) = x + 2 * y + z`;
4. упростив выражение, получим `x = z`, поэтому если переместить медленный указатель на начало списка, а быстрый на точку, где они встретились и передвигать их с одинаковой скоростью в `1`, то они встретятся на начале цикла.

Сверху доказательство немного упрощено, в этом видео можно найти его более полную версию: https://www.youtube.com/watch?v=PvrxZaH_eZ4&t=3s.

---
## Преимущества

Позволяет эффективно решать категории задач, связанных с циклом и связными списками.

---
## Использование

### Есть ли цикл в списке?

Дается `head` `связного списка`, нужно определить содержит ли он в себе цикл.

Заводим `slowPointer` и `fastPointer`, которые указывают изначально на `head`. Далее создается цикл с условиями:
1. если текущий быстрый указатель не `null`;
2. если следующий узел быстрого указателя не `null`.

Первое условия нужно, потому что список может быть из `0` элементов, и потому что быстрый указатель должен остановить на `null`.

Второе условие нужно, потому что список может быть из `1` элемента, и потому что быстрый указатель должен остановиться на последнем элементе списка.

Далее передвигаем указатели медленный на `1` узел, а быстрый на `2` соответственно. Если после передвижения они оказались равны, то цикл найден.

```typescript
const hasCycle = (head: ListNode | null): boolean => {
  let slowPointer = head;
  let fastPointer = head;

  for (;fastPointer !== null && fastPointer.next !== null;) {
    slowPointer = slowPointer.next;
    fastPointer = fastPointer.next.next;

    if (slowPointer === fastPointer) return true;
  }

  return false;
};
```
### На каком узле начинается цикл?

Алгоритм определения цикла такой же, как и выше, только здесь используется флаг, если он станет `true`, то алгоритм перейдет к следующей части, если нет, то функция вернет `null`.

Далее перемещаем медленный указатель на начало списка, а быстрый оставляем там же. Теперь нам нужно найти узел, где встретятся медленный и быстрый указатель вновь, но скорость у указателей теперь одинакова и составляет `1` узел за раз. 

```typescript
const detectCycle = (head: ListNode | null): ListNode | null => {
  let slowPointer = head;
  let fastPointer = head;
  let cycleDetected = false;

  for (; fastPointer !== null && fastPointer.next !== null;) {
    slowPointer = slowPointer.next;
    fastPointer = fastPointer.next.next;

    if (slowPointer === fastPointer) {
      cycleDetected = true;

      break;
    }
  }

  if (!cycleDetected) return null;

  slowPointer = head;

  for (; slowPointer !== fastPointer ;) {
    slowPointer = slowPointer.next;
    fastPointer = fastPointer.next;
  }

  return slowPointer;
};
```

Важно отметить, что узлы на которые указывают `лидирующий и отстающий указатель` должны быть разными.

---
## Задачи, с применением техники

```dataviewjs
const { utils } = require(app.vault.adapter.basePath + "/Files/JS/dataviewUtils.js");

const {
  renderTasksTable,
} = utils;

renderTasksTable(dv, ["Tasks", "Level", "Recommended", "Topics"]);
```