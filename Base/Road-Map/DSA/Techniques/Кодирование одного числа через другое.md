---
tags:
  - leetcode
  - technique
---
## Описание

Предположим, есть `2` числа `a` и `b`, и нужно закодировать одно число через другое. Самый простой способ это сделать через формулу `encoded = a + n * b`, где `n` - произвольное число, которое должно быть больше `a` и `b`. После кодировки первоначальные числа можно получить по формуле:

1. `a = encoded % n`;
2. `b = Math.floor(encoded / n)` (целочисленное деление).

К примеру, числа `1` и `2` закодируем в числе `10`. `encoded = 1 + 10 * 2 = 21`, `encoded` также может быть `12`, это не имеет значения.

`a = 21 % 10 = 1`
`b = Math.floor(21 / 2) = 2`

---
## Ограничения 

- `a` и `b` должны быть одного знака, либо оба положительные, либо оба отрицательные;
- `n` должны быть больше `a` и `b`.

---
## Преимущества

Благодаря такому кодированию, можно хранить `2` числа в одном, а значит модифицировать массив, который подается на вход, как пример, сократить сложность по памяти с `O(n)` до `O(1)`.

---
## Использование

### Особенности кодирования и декодирования

>Важно отметить, что `a` - значение, при помощи которого кодируется, а `b` - значение, которое кодируется и в последующим заменит собой `encoded`.

Происходит это, потому что при извлечении `a` из числа может быть два случая:

1. Число не является изменённым, поэтому оно равняется `a`;
2. Число является закодированной версией `a` и `b`.

В обоих случаях `a` можно достать только при помощи оператора `%`.

К примеру, число `7`, а число `11`, `N = 20`. Тогда закодированное значение будет равняться либо `7 + 11 * 20 = 227`, либо `11 + 7 * 20 = 151`. Чтобы в первом случае достать `7` мы используем `%`, `227 % 20 = 7`, но если вместо изменённого значение будет начальное значение, то всё будет также валидно, ведь `7 % 20 = 7`. А если бы мы собирались доставать при помощи оператора `/`, то получили `Math.floor(227 / 20) = 11` и `Math.floor(7 / 20) = 0`, но не `11`. Тоже самое верно и с `11 + 7 * 20 = 151`.

> Поэтому `a` это с помощью чего происходит кодирование, `b` это что кодируем. И только так.

Для удобства операции по кодированию и декодированию вынесены в функции `encode` и `decode`.

```typescript
const encode = (n: number) => {
  return (a: number, b: number) => {
    return a + n * b;
  }
}

const decode = (n: number) => {
  return (encoded: number, choice: "a" | "b") => {
    if (choice === "a") {
      return encoded % n;
    } else {
      return Math.floor(encoded / n);
    }
  }
}

const getUtils = (n: number) => {
  return {
    encode: encode(n),
    decode: decode(n),
  }
}
```

Из описанного выше ясно что, функция `decode` может понадобиться в двух случаях:

1. Когда из изменённого/не изменённого значения хотим достать `a` (изначальное), оно может понадобится для кодирование другого значения. Используем `decode` с `choice = a`;
2. Когда из изменённого хотим достать `b` (финальное), которое кодировалось с целью последующей замены изменённого значения на текущем индексе. Используем `decode` с `choice = b`.

### Пример 1

К примеру, есть массив `nums = [0,2,1,5,3,4]`, и нужно сделать массив `ans`, где `ans[i] = nums[nums[i]]`. Причем каждый элемент массива удовлетворяет требованию `0 <= nums[i] <= 1000`.

Сначала выбирается `N`, которое будет больше, чем `a` или `b`, в данном случае подойдет `N = 1001`. Раз на место `nums[i]` нужно положить `nums[nums[i]]`, то его и кладём в качестве `b` в `encode`. Но так как оно может быть изменено декодируем при помощи двух `decode` с выбором `a`.

А в конце достаём `b` при помощи `decode` с выбором `b`.

```typescript
const N = 1001;

const buildArray = (nums: number[]): number[] => {
  const { encode, decode } = getUtils(N);

  for (let i = 0; i < nums.length; i += 1) {
    const newPosition = decode(nums[i], "a");

    nums[i] = encode(nums[i], decode(nums[newPosition], "a"));
  }

  for (let i = 0; i < nums.length; i += 1) {
    nums[i] = decode(nums[i], "b");
  }

  return nums;
};
```

### Пример 2

Если дополнительно хранить знак числа, то можно использовать и для отрицательных чисел с положительными. К примеру, есть массив `array`, и нужно все элементы сдвинуть влево, причем первый элемент вставить на место последнего.

Принцип остается тот же, только :
1. При кодировании используется `Math.abs`, чтобы работать только с положительными числами. 
2. В `signs` хранятся знаки изначальных чисел, это позволяет при декодировании применить корректный знак, так как элементы были сдвинуты, то и их знаки должны быть сдвинуты, корректный знак хранится по индексу `nextIndex`.

```typescript
const N = 10;

const shiftArrayToLeft = (array: number[]) => {
  const { encode, decode } = getUtils(N);

  const signs = array.map((value) => (value > 1 ? 1 : -1));

  for (let i = 0; i < array.length; i += 1) {
    const nextIndex = (i + 1) % array.length;

    array[i] = encode(
      Math.abs(array[i]),
      decode(Math.abs(array[nextIndex]), "a")
    );
  }

  for (let i = 0; i < array.length; i += 1) {
    const nextIndex = (i + 1) % array.length;

    array[i] = decode(array[i], "b") * signs[nextIndex];
  }
};
```

---
## Задачи, с применением техники

```dataviewjs
const { utils } = require(app.vault.adapter.basePath + "/Files/JS/dataviewUtils.js");

const {
  renderTasksTable,
} = utils;

renderTasksTable(dv, ["Tasks", "Level", "Recommended", "Topics"]);
```