---
tags:
  - leetcode
  - technique
---
## Описание

`Скользящее окно` - техника, которая позволяет эффективно решать проблемы, включающие определение окна или диапазона входных данных (массивов или строк), а затем перемещение этого окна по данным или выполнения некоторой операции внутри окна. Эта техника обычно используется в таких алгоритмах, как поиск подмассивов с определенной суммой, поиск самой длинной подстроки с уникальными символами или решение задач, требующих окна фиксированного размера для эффективной обработки элементов.

Используется в двух вариантах:
1. Фиксированный размер;
2. Динамический размер.
### Фиксированный размер

Алгоритм следующий:

- Найти размер требуемого окна, скажем `K`;
- Вычислить результат для первого окна, то есть включить первые `K` элементов структуры данных;
- Использовать цикл, чтобы сдвинуть окно на `1`, исключив при этом значение, которое осталось позади окна, и, включив значение, которое вошло в окно, продолжать вычисления окна за окном, пока индекс меньше, чем длина структуры данных.

### Динамический размер

Алгоритм следующий:

- Увеличивать правый указатель до тех пор, пока условие не станет истинным;
- Если условие не соответствует, то мы уменьшить размер окна, увеличивая левый указатель;
- Когда наше условие удовлетворяется, мы снова увеличиваем правый указатель;
- Выполняем эти шаги, пока не дойдем до конца массива.

### Как распознать этот паттерн

- Эти проблемы обычно требуют найти максимум/минимум `подстроки`, `подмассива`, которые удовлетворяют некоторым условиям;
- Размер `подстроки`, `подмассива` `K` будет дано в некоторых проблемах;
- Эти проблемы могут быть легко решены за `O(n^2)` используя вложенные циклы, но техника улучшить этот показатель до `O(n)`.

### Чем отличается от паттерна Два указателя

Техника `скользящее окно` похож на [[Два указателя]], но главное различие заключается в том, что в `два указателя` мы сравниваем значения, которые находятся на этих указателях, вместо того, чтобы использовать все значения, находящиеся между указателями, как это делается в технике `скользящее окно`.

---
## Ограничения 

- `N <= 10^6`, если `N` — размер массива/строки.

---
## Преимущества

Проблемы, которые можно решить при помощи перебора за `O(n^2)`по времени могут быть решены при помощи техники `скользящее окно` за `O(n)` по времени.

---
## Использование варианта окна с фиксированным размером

Есть строка `s`, нужно найти в ней количество подстрок размером `3`, в которых все буквы будут уникальные.

Раз здесь указан размер подстроки/подмассива, то нужно использовать скользящее окно с фиксированным размером. Такой алгоритм есть в двух вариантах.

### Фиксированный размер

Как было сказано в алгоритме выше сначала вычисляем значение начального окна, этим занимается первый цикл. Затем двигаем окно, удаляя из него значение, которое должно выйти и добавляя значение, которое должно зайти. Для операций используется `Map`, так как `Map` работает быстрее и занимает меньше памяти, чем `Object` ([[Object vs Map]]).

Является ли текущая строка подходящей определяется размером `map`, если его размер равен `3`, то это нужная нам строка.

Методы `incrementElementFrequencyInMap` и `decrementElementFrequencyInMap` описаны в рецепте [[Хранение частоты элемента в hashmap]].

```typescript
const countGoodSubstrings = (s: string): number => {
  const map = new Map();
  const windowSize = 3;

  let countOfGoodStrings = 0;

  for (let i = 0; i < windowSize; i += 1) {
    incrementElementFrequencyInMap(map, s[i]);
  }

  if (map.size === windowSize) {
    countOfGoodStrings += 1;
  }

  for (let i = windowSize; i < s.length; i += 1) {
    decrementElementFrequencyInMap(map, s[i - windowSize])
    incrementElementFrequencyInMap(map, s[i]);

    if (map.size === windowSize) {
      countOfGoodStrings += 1;
    }
  }

  return countOfGoodStrings;
};
```

---
## Использование варианта окна с динамическим размером

Дается массив чисел `nums`. Нужно найти подмассив с уникальными числами, чья длина будет максимальной.
### Динамический размер

Алгоритм состоит из внешнего и внутреннего цикла. 

Внешний цикл отвечает за передвижение правой границы окна, он двигает границу от `0` до длины структуры данных. Внешний цикл отвечает за расширение окна, поэтому увеличиваются соответствующие значения, к примеру, размер окна, длина подпоследовательности, занесение в `hashMap` значения и т.д.

Внутренний цикл отвечает за передвижение левой границы окна, он двигает границу до тех пор, пока поставленной в цикле условие не перестанет выполняться. Внутренний цикл отвечает за сужение окна, поэтому уменьшаются соответствующие значения, к примеру, размер окна, длина подпоследовательности, удаление из `hashMap` значения и т.д.

В задаче нужно найти максимальную длину подмассива с уникальными значениями, поэтому строчка с `Math.max` помещена после внутреннего цикла, так как внутренний цикл сдвинет левую границу окна до той поры, пока в подмассиве не останутся только уникальные элементы.

```typescript
const maximumUniqueSubarray = (nums: number[]): number => {
  const map = new Map();

  let sum = 0;
  let maxSum = 0;
  let windowSize = 0;

  let leftEdge = 0;

  for (let rightEdge = 0; rightEdge < nums.length; rightEdge += 1) {
    sum += nums[rightEdge];
    windowSize += 1;

    incrementElementFrequencyInMap(map, nums[rightEdge]);

    for (; map.size !== windowSize ;) {
      sum -= nums[leftEdge];
      windowSize -= 1;

      decrementElementFrequencyInMap(map, nums[leftEdge]);

      leftEdge += 1;
    }

    maxSum = Math.max(sum, maxSum);
  }

  return maxSum;
};
```

---
## Задачи с применением техники

### Фиксированный размер

```dataviewjs
const { utils } = require(app.vault.adapter.basePath + "/Files/JS/dataviewUtils.js");

const {
  getTaskLabelByItLevel,
} = utils;

const currentFileName = dv.current().file.name;
const TECHNIQUE_TYPE = 'Фиксированный размер';

dv.table(["Task", "Level", "Recommended"], dv.pages('#leetcode')
  .filter(entity => {
    const folder = entity.file.folder;
    const linkArray = dv.array(entity.file.outlinks.values);

    const isTaskContainsTechnique = linkArray.some(link => {
      return link.path.includes(currentFileName) && link.subpath?.includes(TECHNIQUE_TYPE);
    });
    
    return isTaskContainsTechnique;
  })
  .map(entity => {
    return [
      entity.file.link,
      getTaskLabelByItLevel(dv, entity.level),
      entity.recommended ? dv.el("span", "&#9745;") : '',
    ];
  }));
```

### Динамический размер

```dataviewjs
const { utils } = require(app.vault.adapter.basePath + "/Files/JS/dataviewUtils.js");

const {
  getTaskLabelByItLevel,
} = utils;

const currentFileName = dv.current().file.name;
const TECHNIQUE_TYPE = 'Динамический размер';

dv.table(["Task", "Level", "Recommended"], dv.pages('#leetcode')
  .filter(entity => {
    const folder = entity.file.folder;
    const linkArray = dv.array(entity.file.outlinks.values);

    const isTaskContainsTechnique = linkArray.some(link => {
      return link.path.includes(currentFileName) && link.subpath?.includes(TECHNIQUE_TYPE);
    });
    
    return isTaskContainsTechnique;
  })
  .map(entity => {
    return [
      entity.file.link,
      getTaskLabelByItLevel(dv, entity.level),
      entity.recommended ? dv.el("span", "&#9745;") : '',
    ];
  }));
```

## Нужно решить

### Фиксированный размер

1. (30) https://leetcode.com/problems/substring-with-concatenation-of-all-words/description/ 
2. (1176) https://leetcode.com/problems/diet-plan-performance/

### Динамический размер

2. (424) https://leetcode.com/problems/longest-repeating-character-replacement/description/
3. (76) https://leetcode.com/problems/minimum-window-substring/description/
4. (2260) https://leetcode.com/problems/minimum-consecutive-cards-to-pick-up/
7. (992) https://leetcode.com/problems/subarrays-with-k-different-integers/description/
8. (2730) https://leetcode.com/problems/find-the-longest-semi-repetitive-substring/
9. (2573) https://leetcode.com/problems/count-the-number-of-good-subarrays/
10. (1004) https://leetcode.com/problems/max-consecutive-ones-iii/
11. (713) https://leetcode.com/problems/subarray-product-less-than-k/
12. (159) https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/
13. (340) https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/
14. (487) https://leetcode.com/problems/max-consecutive-ones-ii/
17. (1852) https://leetcode.com/problems/distinct-numbers-in-each-subarray/
18. (2024) https://leetcode.com/problems/maximize-the-confusion-of-an-exam/description/
19. (2062) https://leetcode.com/problems/count-vowel-substrings-of-a-string/
20. (395) https://leetcode.com/problems/longest-substring-with-at-least-k-repeating-characters/