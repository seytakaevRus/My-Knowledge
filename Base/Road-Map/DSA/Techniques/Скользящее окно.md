---
tags:
  - leetcode
  - technique
---
## Описание

`Скользящее окно` - техника, которая позволяет эффективно решать проблемы, включающие определение окна или диапазона входных данных (массивов или строк), а затем перемещение этого окна по данным или выполнения некоторой операции внутри окна. Эта техника обычно используется в таких алгоритмах, как поиск подмассивов с определенной суммой, поиск самой длинной подстроки с уникальными символами или решение задач, требующих окна фиксированного размера для эффективной обработки элементов.

Используется в двух вариантах:
1. Фиксированный размер;
2. Динамический размер.
### Фиксированный размер

Алгоритм следующий:

- Найти размер требуемого окна, скажем `K`;
- Вычислить результат для первого окна, то есть включить первые `K` элементов структуры данных;
- Затем использовать цикл, чтобы сдвинуть окно на `1`, исключив при этом значение, которое осталось позади окна, и, включив значение, которое вошло в окно, и так продолжать вычислять результат окно за окном.

### Динамический размер

Алгоритм следующий:

- В этом типе задач мы увеличиваем правый указатель до тех пор, пока наше условие не станет истинным;
- На любом этапе, если наше условие не соответствует, то мы уменьшаем размер нашего окна, увеличивая левый указатель;
- Когда наше условие удовлетворяется, мы снова увеличиваем правый указатель;
- Выполняем эти шаги, пока не дойдем до конца массива.

### Как распознать этот паттерн

- Эти проблемы обычно требуют найти максимум/минимум `подстроки`, `подмассива`, которые удовлетворяют некоторым условиям;
- Размер `подстроки`, `подмассива` `K` будет дано в некоторых проблемах;
- Эти проблемы могут быть легко решены за `O(n^2)` используя вложенные циклы, но техника улучшить этот показатель до `O(n)`.

### Чем отличается от паттерна Два указателя

Техника `скользящее окно` похож на [[Два указателя]], но главное различие заключается в том, что в `два указателя` мы сравниваем значения, которые находятся на этих указателях, вместо того, чтобы использовать все значения, находящиеся между указателями, как это делается в технике `скользящее окно`.

---
## Ограничения 

- `N <= 10^6`, если `N` — размер массива/строки.

---
## Преимущества

Проблемы, которые можно решить при помощи перебора за `O(n^2)`по времени могут быть решены при помощи техники `скользящее окно` за `O(n)` по времени.

---
## Использование

Есть строка `s`, нужно найти в ней количество подстрок размером `3`, в которых все буквы будут уникальные.

Раз здесь указан размер подстроки/подмассива, то нужно использовать скользящее окно с фиксированным размером. Такой алгоритм есть в двух вариантах.

### Фиксированный размер. Вариант 1

Как было сказано в алгоритме выше сначала вычисляем значение начального окна, этим занимается первый цикл. Затем двигаем окно, удаляя из него значение, которое должно выйти и добавляя значение, которое должно зайти. Для операций используется `Map`, так как `Map` работает быстрее и занимает меньше памяти, чем `Object` ([[Object vs Map]]).

Является ли текущая строка подходящей определяется размером `map`, если его размер равен `3`, то это нужная нам строка.

Методы `incrementElementFrequencyInMap` и `decrementElementFrequencyInMap` описаны в рецепте [[Хранение частоты элемента в hashmap]].

```typescript
const countGoodSubstrings = (s: string): number => {
  const map = new Map();
  const windowSize = 3;

  let countOfGoodStrings = 0;

  for (let i = 0; i < windowSize; i += 1) {
    incrementElementFrequencyInMap(s[i], map);
  }

  if (map.size === windowSize) {
    countOfGoodStrings += 1;
  }

  for (let i = windowSize; i < s.length; i += 1) {
    decrementElementFrequencyInMap(s[i - windowSize], map)
    incrementElementFrequencyInMap(s[i], map);

    if (map.size === windowSize) {
      countOfGoodStrings += 1;
    }
  }

  return countOfGoodStrings;
};
```

### Фиксированный размер. Вариант 2

Этот вариант отличается от предыдущего тем, что здесь накопление начального значения окна и перемещение окна происходит в одном цикле.

Методы `incrementElementFrequencyInMap` и `decrementElementFrequencyInMap` описаны в рецепте [[Хранение частоты элемента в hashmap]].

```typescript
const countGoodSubstrings = (s: string): number => {
  const map = new Map();
  const windowSize = 3;

  let countOfGoodStrings = 0;

  for (let i = 0; i < s.length; i += 1) {
    if (i >= windowSize) {
      decrementElementFrequencyInMap(s[i - windowSize], map);
    }

    incrementElementFrequencyInMap(s[i], map);

    if (map.size === windowSize) {
      countOfGoodStrings += 1;
    }
  }

  return countOfGoodStrings;
}
```

По сути варианты одинаковые, отличаются лишь количеством строк кода, во втором варианте их меньше, и читаемостью кода, в первом вариант она лучше. Поэтому какой вариант использовать решать тебе.

---
## Задачи, с применением техники

### Фиксированный размер

```dataviewjs
const currentFileName = dv.current().file.name;
const TECHNIQUE_TYPE = 'Фиксированный размер';

dv.table(["Task", "Recommended"], dv.pages('#leetcode')
  .filter(entity => {
    const folder = entity.file.folder;
    const linkArray = dv.array(entity.file.outlinks.values);

    const isTaskContainsTechnique = linkArray.some(link => {
      return link.path.includes(currentFileName) && link.subpath?.includes(TECHNIQUE_TYPE);
    });
    
    return isTaskContainsTechnique;
  })
  .map(entity => {    
    return [entity.file.link,
      entity.recommended ? dv.el("span", "&#9745;") : ''
    ];
  }));
```

### Динамический размер

```dataviewjs
const currentFileName = dv.current().file.name;
const TECHNIQUE_TYPE = 'Динамический размер';

dv.table(["Task", "Recommended"], dv.pages('#leetcode')
  .filter(entity => {
    const folder = entity.file.folder;
    const linkArray = dv.array(entity.file.outlinks.values);

    const isTaskContainsTechnique = linkArray.some(link => {
      return link.path.includes(currentFileName) && link.subpath?.includes(TECHNIQUE_TYPE);
    });
        
    return isTaskContainsTechnique;
  })
  .map(entity => {    
    return [entity.file.link,
      entity.recommended ? dv.el("span", "&#9745;") : ''
    ];
  }));
```

## Нужно решить

### Фиксированный размер

1. (30) https://leetcode.com/problems/substring-with-concatenation-of-all-words/description/ 
2. (1297) https://leetcode.com/problems/maximum-number-of-occurrences-of-a-substring/description/ 
3. (2090) https://leetcode.com/problems/k-radius-subarray-averages/description/ 
4. (1343) https://leetcode.com/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/
6. (2653) https://leetcode.com/problems/sliding-subarray-beauty/description/
8. (187) https://leetcode.com/problems/repeated-dna-sequences/description/
9. (1100) https://leetcode.com/problems/find-k-length-substrings-with-no-repeated-characters/
10. (1151) https://leetcode.com/problems/minimum-swaps-to-group-all-1s-together/
11. (1176) https://leetcode.com/problems/diet-plan-performance/
12. (1652) https://leetcode.com/problems/defuse-the-bomb
14. (2379) https://leetcode.com/problems/minimum-recolors-to-get-k-consecutive-black-blocks/description/
15. (395) https://leetcode.com/problems/longest-substring-with-at-least-k-repeating-characters/

### Динамический размер

1. (3) https://leetcode.com/problems/longest-substring-without-repeating-characters/description/
2. (424) https://leetcode.com/problems/longest-repeating-character-replacement/description/
4. (76) https://leetcode.com/problems/minimum-window-substring/description/
5. (209) https://leetcode.com/problems/minimum-size-subarray-sum/description/
6. (2260) https://leetcode.com/problems/minimum-consecutive-cards-to-pick-up/
7. (1695) https://leetcode.com/problems/maximum-erasure-value/description/
8. (904) https://leetcode.com/problems/fruit-into-baskets/description/
9. (1248) https://leetcode.com/problems/count-number-of-nice-subarrays/description/
10. (413) https://leetcode.com/problems/arithmetic-slices/description/
11. (992) https://leetcode.com/problems/subarrays-with-k-different-integers/description/
12. (2730) https://leetcode.com/problems/find-the-longest-semi-repetitive-substring/
13. (2573) https://leetcode.com/problems/count-the-number-of-good-subarrays/
14. (1658) https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/
15. (1004) https://leetcode.com/problems/max-consecutive-ones-iii/
16. (713) https://leetcode.com/problems/subarray-product-less-than-k/
17. (159) https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/
18. (340) https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/
19. (487) https://leetcode.com/problems/max-consecutive-ones-ii/
20. (1493) https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/description/
21. (1838) https://leetcode.com/problems/frequency-of-the-most-frequent-element/
22. (1852) https://leetcode.com/problems/distinct-numbers-in-each-subarray/
23. (2024) https://leetcode.com/problems/maximize-the-confusion-of-an-exam/description/
24. (2062) https://leetcode.com/problems/count-vowel-substrings-of-a-string/