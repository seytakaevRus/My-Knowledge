---
tags:
  - leetcode
  - technique
---
## Описание

`Скользящее окно` - техника, которая позволяет эффективно решать проблемы, включающие определение окна или диапазона входных данных (массивов или строк), а затем перемещение этого окна по данным или выполнения некоторой операции внутри окна. Эта техника обычно используется в таких алгоритмах, как поиск подмассивов с определенной суммой, поиск самой длинной подстроки с уникальными символами или решение задач, требующих окна фиксированного размера для эффективной обработки элементов.

Используется в двух вариантах:
1. Фиксированный размер;
2. Динамический размер.
### Фиксированный размер

Алгоритм следующий:

- Найти размер требуемого окна, скажем `K`;
- Вычислить результат для первого окна, то есть включить первые `K` элементов структуры данных;
- Затем использовать цикл, чтобы сдвинуть окно на `1`, исключив при этом значение, которое осталось позади окна, и, включив значение, которое вошло в окно, и так продолжать вычислять результат окно за окном.

### Динамический размер

Алгоритм следующий:

- В этом типе задач мы увеличиваем правый указатель до тех пор, пока наше условие не станет истинным;
- На любом этапе, если наше условие не соответствует, то мы уменьшаем размер нашего окна, увеличивая левый указатель;
- Когда наше условие удовлетворяется, мы снова увеличиваем правый указатель;
- Выполняем эти шаги, пока не дойдем до конца массива.

### Как распознать этот паттерн

- Эти проблемы обычно требуют найти максимум/минимум `подстроки`, `подмассива`, которые удовлетворяют некоторым условиям;
- Размер `подстроки`, `подмассива` `K` будет дано в некоторых проблемах;
- Эти проблемы могут быть легко решены за `O(n^2)` используя вложенные циклы, но техника улучшить этот показатель до `O(n)`.

### Чем отличается от паттерна Два указателя

Техника `скользящее окно` похож на [[Два указателя]], но главное различие заключается в том, что в `два указателя` мы сравниваем значения, которые находятся на этих указателях, вместо того, чтобы использовать все значения, находящиеся между указателями, как это делается в технике `скользящее окно`.

---
## Ограничения 

- `N <= 10^6`, если `N` — размер массива/строки.

---
## Преимущества

Проблемы, которые можно решить при помощи перебора за `O(n^2)`по времени могут быть решены при помощи техники `скользящее окно` за `O(n)` по времени.

---
## Использование

В качестве задачи возьмем [[643|Maximum Average Subarray I]].

В задаче есть `k` - длина подмассива, значит можно использовать `фиксированное скользящее окно`, нужно вычислить максимальное среднее значение в подмассиве, поэтому заводим переменную `maxSum`. В соответствии с алгоритмом, описанным выше, сначала вычисляем значение первого окна, которого располагается от `0` до `k - 1` включительно. Далее предыдущее значение удаляется из значения окна, а текущее добавляется к нему. Таким образом получается переиспользовать сумму из предыдущего окна, не вычисляя сумму заново. 

Далее сравнивается `sum` и `maxSum`, чтобы найти максимальную. А в конце вычисляем среднее значение, раз сумма была максимальная, а `k` фиксированное, то и среднее значение будет максимальным.

```typescript
const findMaxAverage = (nums: number[], k: number): number => {
  let maxSum = Number.MIN_SAFE_INTEGER;
  let sum = 0;

  for (let i = 0; i < k; i += 1) {
    sum += nums[i];
  }

  maxSum = sum;

  for (let i = k; i < nums.length; i += 1) {
    sum = sum - nums[i - k] + nums[i];

    maxSum = Math.max(maxSum, sum);
  }

  return maxSum / k;
};
```

Предыдущее решение разбито на два цикла, но можно это сделать и с помощью одного.

```typescript
const findMaxAverage = (nums: number[], k: number): number => {
  let sum = 0;
  let maxSum = 0;

  for (let i = 0; i < nums.length; i += 1) {
    if (i < k) {
      sum += nums[i];

      maxSum = sum;
    } else {
      sum = sum - nums[i - k] + nums[i];

      maxSum = Math.max(maxSum, sum);
    }
  }

  return maxSum / k;
};
```

Как по мне, то решение с `2` циклами выглядит более читаемым, так как первый цикл отвечает за создание значения окна, а второй цикл двигает это окно.

---
## Задачи, с применением техники

### Фиксированный размер

```dataviewjs
const currentFileName = dv.current().file.name;
const FOLDERS_WITH_TASKS = ['Computed tasks', 'Raw tasks', 'Tasks'];
const TECHNIQUE_TYPE = 'Фиксированный размер';

console.log(dv.current());

dv.table(["Task"], dv.pages('#leetcode')
  .filter(entity => {
    const folder = entity.file.folder;
    const linkArray = dv.array(entity.file.outlinks.values);

    const isTask = FOLDERS_WITH_TASKS.some((folderWithTask) => folder.includes(folderWithTask));
    const isTaskContainsTechnique = linkArray.some(link => {
      return link.path.includes(currentFileName) && link.subpath?.includes(TECHNIQUE_TYPE);
    });
        
    return isTask && isTaskContainsTechnique;
  })
  .map(entity => {
    return [entity.file.link];
  }));
```

### Динамический размер

```dataviewjs
const currentFileName = dv.current().file.name;
const FOLDERS_WITH_TASKS = ['Computed tasks', 'Raw tasks', 'Tasks'];
const TECHNIQUE_TYPE = 'Динамический размер';

console.log(dv.current());

dv.table(["Task"], dv.pages('#leetcode')
  .filter(entity => {
    const folder = entity.file.folder;
    const linkArray = dv.array(entity.file.outlinks.values);

    const isTask = FOLDERS_WITH_TASKS.some((folderWithTask) => folder.includes(folderWithTask));
    const isTaskContainsTechnique = linkArray.some(link => {
      return link.path.includes(currentFileName) && link.subpath?.includes(TECHNIQUE_TYPE);
    });
        
    return isTask && isTaskContainsTechnique;
  })
  .map(entity => {
    return [entity.file.link];
  }));
```