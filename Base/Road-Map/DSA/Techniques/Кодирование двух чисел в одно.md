---
tags:
  - leetcode
  - technique
---
## Описание

Предположим, есть 2 числа `a` и `b` и их нужно закодировать в одно число. Самый простой способ это сделать через формулу `encoded = a + n * b`, где `n` - произвольное число, которое должно быть больше `a` и `b`. После кодировки первоначальные числа можно получить по формуле:

1. `a = encoded % n`;
2. `b = Math.floor(encoded / n)` (целочисленное деление).

К примеру, числа `1` и `2` закодируем в числе `10`. `encoded = 1 + 10 * 2 = 21`, `encoded` также может быть `12`, это не имеет значения.

`a = 21 % 10 = 1`
`b = Math.floor(21 / 2) = 2`

---
## Ограничения 

- `a` и `b` должны быть одного знака, либо оба положительные, либо оба отрицательные;
- `n` должны быть больше `a` и `b`.

---
## Преимущества

Благодаря такому кодированию, можно хранить 2 числа в одном, а значит модифицировать массив, который подается на вход, как пример, сократить сложность по времени с `O(n)` до `O(1)`.

---
## Использование

К примеру, есть массив `nums = [0,2,1,5,3,4]`, и нужно сделать массив `ans`, где `ans[i] = nums[nums[i]]`. Причем каждый элемент массива удовлетворяет требованию `0 <= nums[i] <= 1000`.

Сначала выбирается `N`, которое будет больше, чем `a` или `b`, в данном случае подойдет `N = 1001`.

В `value` может находится модифицированное значение, которое было записано туда на предыдущих итерациях, чтобы достать из него изначальное значение используется запись`value % N`. В качестве `a` используется текущее значение из `nums`, в качестве `b` используется `nums[nums[i]]`. Далее во втором цикле достаем `b` из `value` при помощи `Math.floor(value / N)`.

```typescript
const buildArray = (nums: number[]): number[] => {
  const N = 1001;

  nums.forEach((value, index) => {
    const correctValue = value % N;

    nums[index] = correctValue + (nums[correctValue] % N) * N;
  });

  nums.forEach((value, index) => {
    nums[index] = Math.floor(value / N);
  })

  return nums;
};
```
 
Если дополнительно хранить знак числа, то можно использовать и для отрицательных чисел с положительными. К примеру, есть массив `array`, и нужно все элементы сдвинуть влево, причем первый элемент вставить на место последнего.

Принцип остается тот же, только :
1. При кодировании используется `Math.abs`, чтобы работать только с положительными числами. 
2. В `signs` хранятся знаки изначальных чисел, это позволяет при декодировании применить корректный знак, так как элементы были сдвинуты, то и их знаки должны быть сдвинуты, корректный знак хранится в `nextIndex`.

```typescript
const N = 1001;
const array = [-1, 2, -3, 4, -5];
const signs = array.map((value) => value > 1 ? 1 : -1);

// Coding
for (let i = 0; i < array.length; i++) {
  const nextIndex = (i + 1) % array.length;

  array[i] = Math.abs(array[i]) + N * (Math.abs(array[nextIndex]) % N);
}

// Decoding
for (let i = 0; i < array.length; i++) {
  const nextIndex = (i + 1) % array.length;

  array[i] = Math.floor(array[i] / N) * signs[nextIndex];
}
```

---
## Задачи, с применением техники

```dataviewjs
const { utils } = require(app.vault.adapter.basePath + "/Files/JS/dataviewUtils.js");

const {
  renderTasksTable,
} = utils;

renderTasksTable(dv, ["Tasks", "Level", "Recommended", "Topics"]);
```