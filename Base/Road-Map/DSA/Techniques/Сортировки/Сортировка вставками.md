---
tags:
  - leetcode
  - technique
---
## Описание

`Сортировка вставками (insertion sort)` - алгоритм сортировки на месте.

Идея в том, чтобы просматривать элементы по одному во входной последовательности и каждый новый элемент размещать в подходящее место среди ранее упорядоченных элементов.
### Алгоритм

1. Начинать нужно с первого элемента в массиве;
2. Сравнивается текущий элемент с предыдущим, текущий элемент запоминается. Если текущий элемент (`i`) меньше предыдущего (`i - 1`), то эти два элемента меняются местами;
3. Теперь сравнивается текущий элемент на новой позиции (`i - 1`) с его предыдущим элементов (`i - 2`), если текущий меньше, что происходит обмен, и так до тех пор, пока текущий элемент будет меньше предыдущего;
4. Если текущий элемент больше предыдущего, то цикл идёт на новую итерацию.

---
## Ограничения

- в худшем и среднем случае алгоритм занимает `O(n^2)` по времени;

---
## Преимущества

- алгоритм сортирует на месте, а значит занимает `O(1)` по памяти.

---
## Использование

### Вариант 1

Внешний цикл тривиальный, поэтому нас интересует только внутренний цикл. Раз нам нужно сравнить текущий элемент (`i`) и предыдущий (`i - 1`), но нужно сохранить ссылку на текущий элемент, поэтому сделаем следующее. Заведём `j`, которая равняется `i - 1` и которая будет указывать на предыдущий элемент, а чтобы сохранить ссылку на текущий элемент можно использовать индекс `j + 1`, затем производим обмен значениями и уменьшаем `j` на `1`.

```typescript
const insertionSort = (nums: number[]) => {
  for (let i = 1; i < nums.length; i += 1) {
    for (let j = i - 1; j >= 0 && nums[j + 1] < nums[j]; j -= 1) {
      [nums[j + 1], nums[j]] = [nums[j], nums[j + 1]];
    }
  }
};
```

### Вариант 2

Вместо обмена значениями между текущим и предыдущими элементами можно сдвинуть все предыдущие элементы на их нужные места, и на освободившиеся место поставить текущий. Такой алгоритм  должен занимать меньше операций по перемещению элементов.

```typescript
const sortArray = (nums: number[]): number[] => {
  for (let i = 1; i < nums.length; i += 1) {
    let temp = nums[i];
    let j = i - 1;

    for (; j >= 0 && temp < nums[j]; j -= 1) {
      nums[j + 1] = nums[j];
    }

    nums[j + 1] = temp;
  }

  return nums;
};
```

---
## Задачи, с применением техники

```dataviewjs
const { utils } = require(app.vault.adapter.basePath + "/Files/JS/dataviewUtils.js");

const {
  renderTasksTable,
} = utils;

renderTasksTable(dv, ["Tasks", "Level", "Recommended", "Topics"]);
```