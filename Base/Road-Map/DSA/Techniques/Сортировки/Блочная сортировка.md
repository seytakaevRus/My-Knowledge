---
tags:
  - leetcode
  - technique
---
## Описание

`Блочная сортировка (bucket sort)` - алгоритм сортировки, который разделяет элементы массива на несколько блоков по условию. Затем блоки сортируются, используя другие алгоритмы сортировки, к примеру `быстрая сортировка`. После этого элементы из блоков соединяются и получается отсортированный массив.
### Использование в реальных приложениях

- сортировка больших объемах данных, особенно когда они равномерно распределены по диапазону;
- в распределенной системе, где данные разделены между множеством машин, каждая из которых может сортировать блок независимо;

TODO: Написать про внешнюю сортировку и понять, может ли блочная сортировка быть внешней.
### Алгоритм

1. Создать массив из блоков, который изначально пуст;
2. Определиться с условием, которое определяет какой элемент в какой блок пойдет;
3. Пройтись по массиву и положить текущий элемент в нужный блок, исходя из условия;
4. Каждый блок, в котором есть данные должен быть отсортирован (можно применять рекурсивную блочную сортировку или другой алгоритм сортировки, к примеру, `быстрая сортировка`);
5. Пройтись по каждому блоку, забрать от туда элементы и положить их в отдельный массив, благодаря операциям выше этот массив и будет отсортированным.

### Анализ сложности по времени

В лучшем и среднем случае элементы распределяются по всем блокам или только по нескольким. Сортировка выполняется за `O(n + k)`, потому что больше всего времени в алгоритме занимает код ниже. `k` - количество блоков, `n` - общее число элементов, который распределены по `k` блокам.

```typescript
for (let i = buckets.length; i >= 0; i -= 1) {
  if (buckets[i] === undefined) continue;

  for (let j = 0; j < buckets[i].length; j += 1) {
    output += buckets[i][j].repeat(i); 
  }
}
```

Если количество блоков `k` равно количество элементов `n`, то сложность становится `O(n)`.

Хоть и присутствуют `2` вложенных цикла и хочется дать сложность `O(n * k)`, но тогда это бы означало, что в каждом блоке из числа `k` содержится `n` элементов.

В худшем случае все элементы сосредоточены в одном блоке, и элементы в этом блоке находятся в убывающем порядке, поэтому тут зависит от выбранного алгоритма сортировки `O(n * log n)` или `O(n^2)`.

### Анализ сложности по памяти

`k` блоков и `n` элементов дают сложность `O(n + k)` в любом случае, если количество блоков `k` равно количество элементов `n`, то сложность становится `O(n)`.

---
## Ограничения

- эффективность зависит от равномерности распределения элементов по блокам, худший случай дает `O(n^2)` или `O(n log n)`, зависит от выбранного алгоритма сортировки;
- сортировку сложно применять ко всем типам данным, так как для этого нужно найти хорошее условие распределения элементов по блокам;
- помимо условия, нужно еще определять количество блоков, что тоже может влиять на эффективность алгоритма.

---
## Преимущества

- `O(n + k)` по времени в лучшем и среднем случае;
- `O(n + k)` по памяти в худшем случае;
- сортировка каждого блока может обрабатываться параллельно, что можно использовать если есть доступ к потокам или веб-воркерам.

---
## Использование

Рассмотрим использование `блочной сортировки` на примере [[451]]. 

Дана строка `s` нужно отсортировать её по частоте встречаемости букв в убывающем порядке. Если есть несколько ответов, вернуть любой из них.

Сначала создаем массив из блоков (`buckets`), обычно количество блоков равно количеству элементов в оригинальном массиве.

Далее определяемся с условием, по которому будем распределять элементы по блокам, раз нужно отсортировать элементы по частоте встречаемости, то частота и будет отвечать за номер блока, куда попадет элемент, поэтому сначала подсчитываем частоту букв в строке `s`.

Теперь распределяем элементы по блокам, к примеру, элемент, который встречается `2` раза будет находится в блоке под индексом `2`, таких элементов может быть несколько, поэтому там хранится массив.

Сортировать элементы в отдельном блоке не нужно, так как по условию задачи подойдет любой ответ, где порядок частот будет убывающим.

Проходимся по всем блокам, начиная с конца, так как в ответе сначала должны идти максимальные частоты, пустые блоки пропускаем. Внутренний цикл используется, так как в блоке может быть несколько элементов, а `String.prototype.repeat` позволяет повторить строку несколько раз.

```typescript
const frequencySort = (s: string): string => {
  const buckets = new Array(s.length);
  const hashMap = new Map();

  let output = '';

  for (const letter of s) {
    if (!hashMap.has(letter)) {
      hashMap.set(letter, 0);
    }

    hashMap.set(letter, hashMap.get(letter) + 1);
  }

  for (const [key, value] of hashMap) {
    if (buckets[value] === undefined) {
      buckets[value] = [];
    }

    buckets[value].push(key);
  }

  for (let i = buckets.length; i >= 0; i -= 1) {
    if (buckets[i] === undefined) continue;

    for (let j = 0; j < buckets[i].length; j += 1) {
      output += buckets[i][j].repeat(i); 
    }
  }

  return output;
};
```

---
## Задачи, с применением техники

```dataviewjs
const { utils } = require(app.vault.adapter.basePath + "/Files/JS/dataviewUtils.js");

const {
  renderTasksTable,
} = utils;

renderTasksTable(dv, ["Tasks", "Level", "Recommended", "Topics"]);
```