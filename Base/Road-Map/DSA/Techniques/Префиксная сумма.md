---
tags:
  - leetcode
  - technique
---
## Описание

`Префиксная сумма` - техника, используемая в программировании и математике для эффективного вычисления суммы элементов в подмассивах массива.

Также `префиксной суммой` массива `[a0, a1, a2, ..., an-1]` называется массив `[s0, s1, s2, ..., sn]`, который определён следующим образом:

- `s0 = a0`;
- `s1 = s0 + a1 = a0 + a1`;
- `s2 = s1 + a2 = a0 + a1 + a2`;
- `...`;
- `sn = sn-1 + an`.

Встречается также `префиксная сумма`, где первый элемент это `0`, а остальные элементы вычисляются так:

- `s1 = s0`;
- `s2 = s1 + a1 = a0 + a1`;
- `s3 = s2 + a2 = a0 + a1 + a2`;
- `...`;
- `sn = sn-1 + an-1`.

Я предпочитаю первый вариант, где первый элемент префиксной суммы это первый элемент массива.

TODO:
https://leetcode.com/discuss/study-guide/4023666/prefix-sum-questions-to-practice

TODO:
https://leetcode.com/discuss/study-guide/5119937/prefix-sum-problems#section-1

---
## Ограничения

- требует дополнительной `O(n)` памяти;
- не подходит для массивов, чьи элементы могут быть изменены.

---
## Преимущества

- позволяет обрабатывать запросы на суммы в массиве за `O(1)` после предварительного вычисления за `O(n)`;
- позволяет сократить время выполнения с `O(n^2)` до `O(n)`;
- удобна для задач, где требуется многократно вычислять суммы в различных подмассивах.

---
## Использование

### Пример 1

Предположим, есть массив `[1, 2, 3, 4]` и нам нужно получить массив `runningSum[i] = sum(nums[0]…nums[i])`.

Можно решить это через два вложенных цикла и тогда время алгоритма составит `O(n^2)`. А можно пойти через префиксную сумму.

Первый элемент `prefixSum` равен первому элементу `nums`. Далее проход начинается со второго элемента в `nums`, на каждой итерации вычисляется сумма между предыдущим значением `prefixSum` и текущим значением `nums`.

```typescript
const runningSum = (nums: number[]): number[] => {
  const prefixSum = [nums[0]];

  for (let i = 1; i < nums.length; i += 1) {
    prefixSum[i] = prefixSum[i - 1] + nums[i];
  }

  return prefixSum;
};
```

Этот пример показывает как можно получить префиксную сумму, которая поможет оптимизировать время выполнения алгоритма.

### Пример 2

Есть массив слов `words`. Также есть `2D` массив запросов `queries`, запрос просит нас найти количество строк в диапазоне `queries[i] = [left, right]`, в которых гласная буква стоит на первом и последнем месте. Гласная буква в данном случае это `a`, `e`, `i`, `o` или `u`.

`vowels` хранит все гласные буквы в себе и удобно позволяет проверить является текущая буква гласной. А функция `isStringStartsAndEndsWithVowel` проверяет, удовлетворяет ли строка условию выше.

Первым шагом является создание `префиксной суммы`, на `i-ой` позиции будет располагаться количество строк, которые удовлетворяют условию и лежат в диапазоне от `[0, i]`.

Далее проходимся по массиву `queries`, достаём от туда `left` и `right`. Если нужно вернуть строки в диапазоне `[0, 3]`, то есть когда `left = 0`, то просто возвращаем элемент префиксной суммы с индексом `right`. Если же нужно вернуть `[2, 3]`, то можно взять диапазон `[0, 3]` и отнять от него `[0, 1]`, то есть `prefixSum[right] - prefixSum[left - 1]`.

```typescript
const vowels = new Set("aeiou");

const isStringStartsAndEndsWithVowel = (str: string): boolean => {
  if (vowels.has(str[0]) && vowels.has(str[str.length - 1])) return true;

  return false;
}

const vowelStrings = (words: string[], queries: number[][]): number[] => {
  const output = [];
  const prefixSum = [];

  prefixSum[0] = Number(isStringStartsAndEndsWithVowel(words[0]));

  for (let i = 1; i < words.length; i += 1) {
    prefixSum[i] = prefixSum[i - 1] + Number(isStringStartsAndEndsWithVowel(words[i]));
  }

  for (const [left, right] of queries) {
    if (left === 0) {
      output.push(prefixSum[right]);
    } else {
      output.push(prefixSum[right] - prefixSum[left - 1]);
    }
  }

  return output;
};
```

---
## Задачи, с применением техники

```dataviewjs
const { utils } = require(app.vault.adapter.basePath + "/Files/JS/dataviewUtils.js");

const {
  renderTasksTable,
} = utils;

renderTasksTable(dv, ["Tasks", "Level", "Recommended", "Topics"]);
```