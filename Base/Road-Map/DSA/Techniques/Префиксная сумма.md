---
tags:
  - leetcode
  - technique
---
## Описание

`Префиксная сумма` - техника, используемая в программировании и математике для эффективного вычисления суммы элементов в подмассивах массива.

Также `префиксной суммой` массива `[a0, a1, a2, ..., an-1]` называется массив `[s0, s1, s2, ..., sn]`, который определён следующим образом:

- `s0 = a0`;
- `s1 = s0 + a1 = a0 + a1`;
- `s2 = s1 + a2 = a0 + a1 + a2`;
- `...`;
- `sn = sn-1 + an`.

Встречается также `префиксная сумма`, где первый элемент это `0`, а остальные элементы вычисляются так:

- `s1 = s0`;
- `s2 = s1 + a1 = a0 + a1`;
- `s3 = s2 + a2 = a0 + a1 + a2`;
- `...`;
- `sn = sn-1 + an-1`.

Я предпочитаю первый вариант, где первый элемент префиксной суммы это первый элемент массива.

TODO:
https://leetcode.com/discuss/study-guide/4023666/prefix-sum-questions-to-practice

TODO:
https://leetcode.com/discuss/study-guide/5119937/prefix-sum-problems#section-1

---
## Ограничения

- требует дополнительной `O(n)` памяти;
- не подходит для массивов, чьи элементы могут быть изменены.

---
## Преимущества

- позволяет обрабатывать запросы на суммы в массиве за `O(1)` после предварительного вычисления за `O(n)`;
- позволяет сократить время выполнения с `O(n^2)` до `O(n)`;
- удобна для задач, где требуется многократно вычислять суммы в различных подмассивах.

---
## Использование

### Пример 1

Есть массив `[1, 2, 3, 4]` и нам нужно получить массив `runningSum[i] = sum(nums[0]…nums[i])`.

Можно решить это через два вложенных цикла и тогда время алгоритма составит `O(n^2)`. А можно пойти через префиксную сумму.

Первый элемент `prefixSum` равен первому элементу `nums`. Далее проход начинается со второго элемента в `nums`, на каждой итерации вычисляется сумма между предыдущим значением `prefixSum` и текущим значением `nums`.

```typescript
const runningSum = (nums: number[]): number[] => {
  const prefixSum = [nums[0]];

  for (let i = 1; i < nums.length; i += 1) {
    prefixSum[i] = prefixSum[i - 1] + nums[i];
  }

  return prefixSum;
};
```

Этот пример показывает как можно получить префиксную сумму, которая поможет оптимизировать время выполнения алгоритма.

### Пример 2

Есть массив слов `words`. Также есть `2D` массив запросов `queries`, запрос просит нас найти количество строк в диапазоне `queries[i] = [left, right]`, в которых гласная буква стоит на первом и последнем месте. Гласная буква в данном случае это `a`, `e`, `i`, `o` или `u`.

`vowels` хранит все гласные буквы в себе и удобно позволяет проверить является текущая буква гласной. А функция `isStringStartsAndEndsWithVowel` проверяет, удовлетворяет ли строка условию выше.

Первым шагом является создание `префиксной суммы`, на `i-ой` позиции будет располагаться количество строк, которые удовлетворяют условию и лежат в диапазоне от `[0, i]`.

Далее проходимся по массиву `queries`, достаём от туда `left` и `right`. Если нужно вернуть строки в диапазоне `[0, 3]`, то есть когда `left = 0`, то просто возвращаем элемент префиксной суммы с индексом `right`. Если же нужно вернуть `[2, 3]`, то можно взять диапазон `[0, 3]` и отнять от него `[0, 1]`, то есть `prefixSum[right] - prefixSum[left - 1]`.

```typescript
const vowels = new Set("aeiou");

const isStringStartsAndEndsWithVowel = (str: string): boolean => {
  if (vowels.has(str[0]) && vowels.has(str[str.length - 1])) return true;

  return false;
}

const vowelStrings = (words: string[], queries: number[][]): number[] => {
  const output = [];
  const prefixSum = [];

  prefixSum[0] = Number(isStringStartsAndEndsWithVowel(words[0]));

  for (let i = 1; i < words.length; i += 1) {
    prefixSum[i] = prefixSum[i - 1] + Number(isStringStartsAndEndsWithVowel(words[i]));
  }

  for (const [left, right] of queries) {
    if (left === 0) {
      output.push(prefixSum[right]);
    } else {
      output.push(prefixSum[right] - prefixSum[left - 1]);
    }
  }

  return output;
};
```

### Пример 3

Даётся массив чисел `nums` и число `k`, вернуть общее количество подмассивов, где сумма равняется `k`. Для того, чтобы понять как сюда применить префиксную сумму, нужно рассмотреть на примере. 

Есть массив `[1, -1, 1, 1, 1]` и `k = 2` и возьмём два подмассива `[1]` и `[1, 1, 1]`, у первого сумма подмассива `1`, а у второго `3`, если из второго вычесть сумму первого, то мы получим `k`, значит второй подмассив содержит подмассив с суммой `k`, а нам такие и нужны. Но тогда нужно будет хранить суммы всех подмассивов и перебирать их, поэтому можно сделать так, из суммы второго подмассива `3` вычитаем `k` и получаем `1` и раз эта сумма была нами встречена ранее, то мы можем её удалить и получить `k`.

Для отслеживания сумм, которые мы уже видели, можно использовать `хеш-таблицу`, а для того, чтобы получать сумму подмассива от `[0, i]` можно использовать `префиксную сумму`. А для того, чтобы понять сколько подмассивов содержится в диапазоне `[0, i]`, у которых сумма равна `k`, мы берём сумму текущего подмассив и вычитаем из неё `k`, и если такая сумма была ранее встречена, значит столько подмассивов можно удалить, чтобы получить сумму `k`.

Продебажим пример выше:

```typescript
// 1 - 2 = -1, -1 в хеш-таблице нет, поэтому заносим 1 : 1
// (1 + -1) - 2 = 0 - 2, -2 в хеш-таблице нет, поэтому заносим 0 : 1
// (1 + -1 + 1) - 2 = 1 - 2, -1 в хеш-таблице нет, поэтому заносим 1 : 2
// (1 + -1 + 1 + 1) - 2 = 2 - 2, 0 в хеш-таблице есть, поэтому увеличиваем счётчик на 1, заносим 2 : 1
// (1 + -1 + 1 + 1 + 1) - 2 = 3 - 2, 1 в хеш-таблице есть, поэтому увеличиваем счётчик на 2, заносим 3 : 1
```

Из примера выше важно отметить:

1. `-1` встречается снова на `3` итерации, и если убрать его из подмассива `[1, -1, 1]`, то действительно получится сумма `2`, только полученный `[1, 1]` будет подстрокой, а не подмассивом;
2. на `4` итерации мы получили `2`, потому что из подмассива `[1, -1, 1, 1]` можно удалить первые два элемента. Такие подмассивы являются граничным случаем и их нужно считать отдельно.

```typescript
const subarraySum = (nums: number[], k: number): number => {
  const map = new Map();

  let prefixSum = 0;
  let answer = 0;

  for (let i = 0; i < nums.length; i += 1) {
    prefixSum += nums[i];

    const difference = prefixSum - k;

    if (prefixSum === k) {
      answer += 1;
    }

    if (map.has(difference)) {
      answer += map.get(difference);
    }

    if (!map.has(prefixSum)) {
      map.set(prefixSum, 0);
    }

    map.set(prefixSum, map.get(prefixSum) + 1);
  }

  return answer;
};
```

---
## Задачи, с применением техники

```dataviewjs
const { utils } = require(app.vault.adapter.basePath + "/Files/JS/dataviewUtils.js");

const {
  renderTasksTable,
} = utils;

renderTasksTable(dv, ["Tasks", "Level", "Recommended", "Topics"]);
```