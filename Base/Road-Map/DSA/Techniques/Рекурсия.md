---
tags:
  - leetcode
  - technique
---
## Описание

При использование `рекурсии` мыслить нужно `деларативно`, а не `императивно`, то есть вместо `как это сделать`, а `что я хочу сделать`.

`Рекурсия` декомпозирует большую проблему в несколько более мелких.

![[DSA_Рекурсия_1.png]]

### Структура рекурсии

![[DSA_Рекурсия_2.png]]

1. Текущее состояние (`n`), означает параметр, который был передан. Состояние не может быть изменено, потому что `рекурсия` стремится к чистоте. Данные получаются только отсюда, а не из глобальных переменных вовне;
2. Базовый случай, это условие, по которому `рекурсия` заканчивает своё выполнение. Оно должно быть обязательно. Сюда заносятся случаи, который могут быть вычислены без дальнейшей передачи состояние в другие вызовы функции;
3. Рекурсивный случай, отвечает за переход из текущего состояние к более простому. В конечном итоге этот случай приводится к базовому. Здесь возвращается часть данных и происходит переход в новый вызов функции.



Прекрасное видео с объяснением всей рекурсии  https://www.youtube.com/watch?v=MWyVg6o3hG0.

---
## Ограничения 

---
## Преимущества

1. Может дать простой и декларативный код для проблем с рекурсивной природой (`графы`, `деревья` и т.д.);
2. Помогает разбивать проблему на более мелкие проблемы (навык декомпозиции);
3. Иногда рекурсивный подход бывает более быстрым, чем итеративный подхоl

---
## Недостатки

1. Занимает больше памяти, так как нужно хранить функции на стеке;
2. Производительность может быть ниже, чем при итеративном подходе, но зачастую это не сильно ниже;
3. Возможность переполнение стека;
4. Компилятору сложно оптимизировать рекурсивные вызовы, но есть оптимизация `хвостовая рекурсия`.

---
## Использование

```typescript

```

---
## Задачи, с применением техники

```dataviewjs
const { utils } = require(app.vault.adapter.basePath + "/Files/JS/dataviewUtils.js");

const {
  renderTasksTable,
} = utils;

renderTasksTable(dv, ["Tasks", "Level", "Recommended", "Topics"]);
```