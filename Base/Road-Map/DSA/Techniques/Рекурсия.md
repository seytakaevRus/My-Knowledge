---
tags:
  - leetcode
  - technique
---
## Описание

При использование `рекурсии` мыслить нужно `деларативно`, а не `императивно`, то есть вместо `как это сделать`, а `что я хочу сделать`.

`Рекурсия` декомпозирует большую проблему в несколько более мелких.

![[DSA_Рекурсия_1.png]]

### Структура рекурсии

![[DSA_Рекурсия_2.png]]

1. Текущее состояние (`n`), означает параметр, который был передан. Состояние не может быть изменено, потому что `рекурсия` стремится к чистоте. Данные получаются только отсюда, а не из глобальных переменных вовне;
2. Базовый случай, это условие, по которому `рекурсия` заканчивает своё выполнение. Оно должно быть обязательно. Сюда заносятся случаи, который могут быть вычислены без дальнейшей передачи состояние в другие вызовы функции;
3. Рекурсивный случай, отвечает за переход из текущего состояние к более простому. В конечном итоге этот случай приводится к базовому. Здесь возвращается часть данных и происходит переход в новый вызов функции.

### `Stack Frame`

Каждый рекурсивный вызовы выделяет `stack frame`. По сути `stack frame` - все память, которая нужна вашей функции и адрес, куда нужно вернуться.

![[DSA_Рекурсия_3.png]]

### Переполнение стека

Все `stack frame` хранятся в стеке, и если их будет очень много, то может случиться `stack overflow` (переполнение стека).

![[DSA_Рекурсия_4.png]]

Чаще всего это происходит, потому у рекурсии нет `базового случая`, а значит выход из рекурсии невозможен.

![[DSA_Рекурсия_5.png]]

### Как предотвратить переполнение стека

1. Всегда нужно помнить о наличие базовых случаях в рекурсии;
2. Уменьшить глубину рекурсии (`branch & bound`);
3. Хвостовая оптимизация рекурсии
4. Увеличить размер стека.
### Хвостовая оптимизация рекурсии

Некоторые компиляторы могут оптимизировать рекурсию и превращать её в итеративный алгоритм с циклом, полностью удаляя рекурсивные вызовы и возможность переполнения стека.

![[DSA_Рекурсия_6.png]]

Но это возможно только в определенных случаях. К примеру, выше красным обведён случай, где такая оптимизация невозможна, потому что функция возвращает `n + sum(n - 1)`, `+` это операция, которая выполняется после того, как выполнится `sum(n - 1)`.

Для достижения оптимизации такой случай обведён зеленым, нужно:

1. Из функции возвращать только вызов самой себя, без использования текущего состояния;
2. В параметрах передавать значение, которое будет изменяться с рекурсивными вызовами функций.

### Преимущества хвостовой оптимизации рекурсии

1. Очень эффективно, итерации максимально оптимизированы компилятором;
2. Нет возможности для переполнения стека;
3. Сохраняется чистота кода, как при рекурсии, и функции становятся чистыми. 

### `Branch & Bound`

TODO: Написать про `Branch & Bound`

### `Divide & Conquer` 

TODO: Написать про `Divide & Conquer`

Прекрасное видео с объяснением всей рекурсии  https://www.youtube.com/watch?v=MWyVg6o3hG0.

---
## Ограничения 

---
## Преимущества

1. Может дать простой и декларативный код для проблем с рекурсивной природой (`графы`, `деревья` и т.д.);
2. Помогает разбивать проблему на более мелкие проблемы (навык декомпозиции);
3. Иногда рекурсивный подход бывает более быстрым, чем итеративный подхоl

---
## Недостатки

1. Занимает больше памяти, так как нужно хранить функции на стеке;
2. Производительность может быть ниже, чем при итеративном подходе, но зачастую это не сильно ниже;
3. Возможность переполнение стека;
4. Компилятору сложно оптимизировать рекурсивные вызовы, но есть оптимизация `хвостовая рекурсия`.

---
## Использование

### Вычисление факториала

Факториал числа `n` вычисляется как `n * (n - 1) * (n - 2) * ... * 1`, `0! === 1`.

Базовый случай выхода из рекурсии является тот, когда `n` достигает `0`. В остальных случаях срабатывает рекурсивный случай `n * factorial(n - 1)`.

```typescript
const factorial = (n: number): number => {
  if (n === 0) return 1;

  return n * factorial(n - 1);
}
```

А здесь приведено решение с хвостовой оптимизации рекурсии. Передаём в следующие вызовы `result * n`, по умолчанию, `result` равен `1`. А при достижении базового случая возвращает `result`.

```typescript
const factorialTRO = (n: number, result: number = 1) => {
  if (n === 0) return result;

  return factorialTRO(n - 1, result * n);
}
```

---
## Задачи, с применением техники

```dataviewjs
const { utils } = require(app.vault.adapter.basePath + "/Files/JS/dataviewUtils.js");

const {
  renderTasksTable,
} = utils;

renderTasksTable(dv, ["Tasks", "Level", "Recommended", "Topics"]);
```