---
tags:
  - leetcode
  - technique
---
## Описание

`Бинарный поиск` - тип поискового алгоритма, который последовательно делит пополам заранее отсортированный массив данных, чтобы обнаружить нужный элемент. Его сложность по времени составляет `O(log n)`, где `n` - количество элементов в массиве.

### Основные паттерны

1. [[Бинарный поиск#Поиск элемента|Поиск элемента]];
2. [[Бинарный поиск#Поиск начала или конца диапазона, где все элементы подходят под условие|Поиск начала или конца диапазона, где все элементы подходят под условие]];
3. [[Бинарный поиск#Поиск начала или конца диапазона, где все элементы дубликаты|Поиск начала или конца диапазона, где все элементы дубликаты]];
4. [[Бинарный поиск#Поиск пропущенного элемента|Поиск пропущенного элемента]].

Прекрасное видео с объяснением всего бинарного поиска https://www.youtube.com/watch?v=cwPI_9uu9T0.

---
## Ограничения 

Если массив не упорядочен, то сначала его нужно отсортировать, алгоритм сортировки выбирается по ситуации, но для коротких списков поиск по неотсортированному массиву будет выгоднее.

---
## Преимущества

Поиск работает только в упорядоченном списке, тогда он эффективнее линейного, сложность по времени которого составляет `O(n)`. Также для массивов, размер которых , к примеру, может составлять `10^9` ил `2^31 - 1` `линейный поиск` будет использовать очень долго, поэтому `бинарный` будет одним из выходов.

---
## Использование

Каждый из паттернов ниже привносит свои условия, но принцип работы у них один:

1. Определяем левую и правую границу;
2. Находим серединный индекс, путем сложения левой и правой границы и деления суммы на два;
3. Проверяем элемент на серединном индексе по условию;
4. Решаем какую часть массива точно можно отбросить и обновляем соответствующие границы;
5. Повторяем второй пункт до тех пор, пока левая граница меньше или равна правой.

Исполнение алгоритма может как итеративным, так и рекурсивным.

### Поиск элемента

Нужно найти элемент в массиве.

![[DSA_Бинарный-поиск_1.png]]

![[DSA_Бинарный_поиск_2.png]]

Итеративный подход

```typescript
const binarySearch = (nums: number[], target: number): number => {
  let left = 0;
  let right = nums.length - 1;

  for (;left <= right;) {
    const middle = Math.floor((left + right) / 2);

    if (nums[middle] === target) return middle;

    if (nums[middle] > target) {
      right = middle - 1;
    } else {
      left = middle + 1;
    }
  }

  return -1;
};
```

[[Рекурсия|Рекурсивный]] подход.

```typescript
const search = (nums: number[], target: number, left = 0, right = nums.length - 1): number => {
  if (left > right) return -1;

  const middle = Math.floor((left + right) / 2);

  if (nums[middle] === target) {
    return middle;
  } else if (nums[middle] < target) {
    return search(nums, target, middle + 1, right);
  } else {
    return search(nums, target, left, middle - 1);
  }
};
```

### Поиск начала или конца диапазона, где все элементы подходят под условие

Есть условие, которое мы можем применять к каждому элементу массива. Это условие возвращает либо `true`, либо `false`. И есть граница, которая разделяет элементы, дающие `true`, если применить к им условие, и элементы, дающие `false`. Эти диапазоны будут монотонными (непрерывными), только граница может прервать диапазон один диапазон и начать другой. 

![[DSA_Бинарный-поиск_3.png]]

В зависимости от выбранного условия монотонные диапазоны могут меняться местами.

#### Поиск конца диапазона

К примеру, есть отсортированный массив в убывающем порядке и нужно найти последнее неотрицательное число. Мы знаем, что все неотрицательные числа будут находиться, либо в начале, либо их не будет вовсе. В качестве условия можно взять `>= 0`. Если мы встречаем неотрицательное число, то запоминаем его индекс и отбрасываем левую часть.

```typescript
const findIndexLastNonNegativeNumber = (nums: number[]) => {
  let left = 0;
  let right = nums.length - 1;
  let index = -1;

  for (; left <= right ;) {
    const middle = Math.floor((left + right) / 2);

    if (nums[middle] >= 0) {
      index = middle;

      left = middle + 1;
    } else {
      right = middle - 1;
    }
  }

  return index;
}
```

#### Поиск начала диапазона

К примеру, есть отсортированный массив в убывающем порядке и нужно найти первое отрицательное число. Мы знаем, что все отрицательные числа будут находиться, либо в в конце, либо их не будет вовсе. В качестве условия можно взять `< 0`. Если мы встречаем отрицательное число, то запоминаем его индекс и отбрасываем правую часть.

```typescript
const findIndexFirstNegativeNumber = (nums: number[]) => {
  let left = 0;
  let right = nums.length - 1;
  let index = -1;

  for (; left <= right ;) {
    const middle = Math.floor((left + right) / 2);

    if (nums[middle] < 0) {
      index = middle;

      right = middle - 1;
    } else {
      left = middle + 1;
    }
  }

  return index;
}
```
### Поиск начала или конца диапазона, где все элементы дубликаты

![[DSA_Бинарный-поиск_4.png]]
#### Поиск начала диапазона

К примеру, есть массив чисел, отсортированный в возрастающем порядке, нужно найти первое вхождение `target`.

Так как нам нужно найти первое вхождение `target`, то все что справа от него (либо равный элемент, либо элемент больше) отбрасываем. А если текущий элемент равен `target`, то сохраняем его индекс.

```typescript
const findFirstTargetPosition = (nums: number[], target: number) => {
  let left = 0;
  let right = nums.length - 1;
  let index = -1;

  for (; left <= right; ) {
    const middle = Math.floor((left + right) / 2);

    if (nums[middle] === target) {
      index = middle;
    }

    if (nums[middle] >= target) {
      right = middle - 1;
    } else {
      left = middle + 1;
    }
  }

  return index;
};
```

#### Поиск конца диапазона

К примеру, есть массив чисел, отсортированный в возрастающем порядке, нужно найти последнее вхождение `target`.

Так как нам нужно найти последнее вхождение `target`, то все что слева от него него (либо равный элемент, либо элемент меньше) отбрасываем. А если текущий элемент равен `target`, то сохраняем его индекс.

```typescript
const findLastTargetPosition = (nums: number[], target: number) => {
  let left = 0;
  let right = nums.length - 1;
  let index = -1;

  for (; left <= right; ) {
    const middle = Math.floor((left + right) / 2);

    if (nums[middle] === target) {
      index = middle;
    }

    if (nums[middle] <= target) {
      left = middle + 1;
    } else {
      right = middle - 1;
    }
  }

  return index;
};
```

### Поиск пропущенного элемента

![[DSA_Бинарный-поиск_5.png]]

В таких задачах либо дают `target`, либо не дают и спрашивают какое число было пропущено.

#### `Target` известен

К примеру, есть массив чисел отсортированный в возрастающем порядке. Нужно найти индекс на которой можно разместить число и массив также останется отсортированным.

1. Ищем сам `target` и если находится, то возвращаем его индекс;
2. Ищем индекс последнего элемента, который меньше `target`;
3. Ищем индекс первого элемент, который больше `target`.

Благодаря индексам, полученным в шагах `2` и `3` вычисляем индекс, на которой можно поставить `target`.

Можно опустить шаг `3`. Если шаг `2` дал индекс `-1`, это значит, что все элементы в массиве больше `target`, поэтому можем поместить его на индекс `0`, если шаг `2` дал индекс не `-1`, то прибавляем к полученному индексу `1` и возвращаем.

```typescript
const searchInsert = (nums: number[], target: number): number => {
  let left = 0;
  let right = nums.length - 1;
  let index = -1;

  for (; left <= right;) {
    const middle = Math.floor((left + right) / 2);

    if (nums[middle] === target) return middle;

    if (nums[middle] < target) {
      index = middle;

      left = middle + 1;
    } else {
      right = middle - 1;
    }
  }

  return index === -1 ? 0 : index + 1;
};
```

#### `Target` не известен

К примеру, есть отсортированный массив чисел в возрастающем порядке, в диапазоне `[0, n]` и в нем пропущено одно число, нужно найти какое.

1. Ищем первое число, чей индекс не равняется самому числу;
2. Если полученный индекс равняется `-1`, то число нужно положить в конец массива;
3. Иначе возвращаем найденный индекс.

```typescript
const missingNumber = (nums: number[]): number => {
  let left = 0;
  let right = nums.length - 1;
  let index = -1;

  for (; left <= right ;) {
    const middle = Math.floor((left + right) / 2);

    if (middle < nums[middle]) {
      index = middle;

      right = middle - 1;
    } else {
      left = middle + 1;
    }
  }

  return index === -1 ? nums.length : index;
};
```

---
## Задачи, с применением техники

```dataviewjs
const { utils } = require(app.vault.adapter.basePath + "/Files/JS/dataviewUtils.js");

const {
  renderTasksTable,
} = utils;

renderTasksTable(dv, ["Tasks", "Level", "Recommended", "Topics"]);
```