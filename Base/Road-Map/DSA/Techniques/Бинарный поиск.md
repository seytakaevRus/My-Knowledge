---
tags:
  - leetcode
  - technique
---
## Описание

`Бинарный поиск` - тип поискового алгоритма, который последовательно делит пополам заранее отсортированный массив данных, чтобы обнаружить нужный элемент. Его сложность по времени составляет `O(log n)`, где `n` - количество элементов в массиве.

### Основные паттерны

1. [[Бинарный поиск#Поиск элемента|Поиск элемента]];
2. [[Бинарный поиск#Поиск начала или конца диапазона, где все элементы подходят под условие|Поиск начала или конца диапазона, где все элементы подходят под условие]];
3. [[Бинарный поиск#Поиск начала или конца диапазона, где все элементы дубликаты|Поиск начала или конца диапазона, где все элементы дубликаты]];
4. [[Бинарный поиск#Поиск пропущенного элемента|Поиск пропущенного элемента]].

Прекрасное видео с объяснением всего бинарного поиска https://www.youtube.com/watch?v=cwPI_9uu9T0.

---
## Ограничения 

Если массив не упорядочен, то сначала его нужно отсортировать, алгоритм сортировки выбирается по ситуации, но для коротких списков поиск по неотсортированному массиву будет выгоднее.

---
## Преимущества

Поиск работает только в упорядоченном списке, тогда он эффективнее линейного, сложность по времени которого составляет `O(n)`. Также для массивов, размер которых , к примеру, может составлять `10^9` ил `2^31 - 1` `линейный поиск` будет использовать очень долго, поэтому `бинарный` будет одним из выходов.

---
## Использование

Каждый из паттернов ниже привносит свои условия, но принцип работы у них один:

1. Определяем левую и правую границу;
2. Находим серединный индекс, путем сложения левой и правой границы и деления суммы на два;
3. Проверяем элемент на серединном индексе по условию;
4. Решаем какую часть массива точно можно отбросить и обновляем соответствующие границы;
5. Повторяем второй пункт до тех пор, пока левая граница меньше или равна правой.

### Поиск элемента

Нужно найти элемент в массиве.

![[DSA_Бинарный-поиск_1.png]]

![[DSA_Бинарный_поиск_2.png]]

```typescript
const binarySearch = (nums: number[], target: number): number => {
  let left = 0;
  let right = nums.length - 1;

  for (;left <= right;) {
    const middle = Math.floor((left + right) / 2);

    if (nums[middle] === target) return middle;

    if (nums[middle] > target) {
      right = middle - 1;
    } else {
      left = middle + 1;
    }
  }

  return -1;
};
```

### Поиск начала или конца диапазона, где все элементы подходят под условие

Есть условие, которое мы можем применять к каждому элементу массива. Это условие возвращает либо `true`, либо `false`. И есть граница, которая разделяет элементы, дающие `true`, если применить к им условие, и элементы, дающие `false`. Эти диапазоны будут монотонными (непрерывными), только граница может прервать диапазон один диапазон и начать другой. 

![[DSA_Бинарный-поиск_3.png]]

В зависимости от выбранного условия диапазон, где каждый элемент возвращает `true` может как перед диапазоном, где каждый элемент возвращает `false`, так и после.

К примеру, есть отсортированный массив в убывающем порядке. Если взять за условие "поиск последнего неотрицательного числа", то диапазон, где все элементы возвращают `true` будет в начале или его не будет вовсе, поэтому при встрече неотрицательного числа мы запоминаем индекс и отбрасываем левую часть, нам же нужно найти последнее число.

```typescript
const findIndexLastNonNegativeNumber = (nums: number[]) => {
  let left = 0;
  let right = nums.length - 1;
  let index = -1;

  for (; left <= right ;) {
    const middle = Math.floor((left + right) / 2);

    if (nums[middle] >= 0) {
      index = middle;
    }

    if (nums[middle] >= 0) {
      left = middle + 1;
    } else {
      right = middle - 1;
    }
  }

  return index;
}
```

А если за условие взять "поиск первого отрицательного числа", то диапазон, где все элементы возвращают `true` будет в конце или его не будет вовсе, поэтому при встрече отрицательного числа мы запоминаем индекс и отбрасываем правую часть, нам же нужно найти первое число.

```typescript
const findIndexFirstNegativeNumber = (nums: number[]) => {
  let left = 0;
  let right = nums.length - 1;
  let index = -1;

  for (; left <= right ;) {
    const middle = Math.floor((left + right) / 2);

    if (nums[middle] < 0) {
      index = middle;
    }

    if (nums[middle] < 0) {
      right = middle - 1;
    } else {
      left = middle + 1;
    }
  }

  return index;
}
```
### Поиск начала или конца диапазона, где все элементы дубликаты

![[DSA_Бинарный-поиск_4.png]]

Поиск начало диапазона. 

Так как нам нужно найти первое вхождение `target`, то все что справа от него (либо равный элемент, либо элемент больше) отбрасываем. А если текущий элемент равен `target`, то сохраняем его индекс.

```typescript
const findFirstTargetPosition = (nums: number[], target: number) => {
  let left = 0;
  let right = nums.length - 1;
  let index = -1;

  for (; left <= right; ) {
    const middle = Math.floor((left + right) / 2);

    if (nums[middle] === target) {
      index = middle;
    }

    if (nums[middle] >= target) {
      right = middle - 1;
    } else {
      left = middle + 1;
    }
  }

  return index;
};
```

Поиск конца диапазона.

Так как нам нужно найти последнее вхождение `target`, то все что слева от него него (либо равный элемент, либо элемент меньше) отбрасываем. А если текущий элемент равен `target`, то сохраняем его индекс.

```typescript
const findLastTargetPosition = (nums: number[], target: number) => {
  let left = 0;
  let right = nums.length - 1;
  let index = -1;

  for (; left <= right; ) {
    const middle = Math.floor((left + right) / 2);

    if (nums[middle] === target) {
      index = middle;
    }

    if (nums[middle] <= target) {
      left = middle + 1;
    } else {
      right = middle - 1;
    }
  }

  return index;
};
```

### Поиск пропущенного элемента

TODO: Дописать алгоритм.

---
## Задачи, с применением техники

```dataviewjs
const { utils } = require(app.vault.adapter.basePath + "/Files/JS/dataviewUtils.js");

const {
  renderTasksTable,
} = utils;

renderTasksTable(dv, ["Tasks", "Level", "Recommended", "Topics"]);
```