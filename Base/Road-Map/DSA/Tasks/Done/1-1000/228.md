---
level: easy
tags:
  - leetcode
linkToTask: https://leetcode.com/problems/summary-ranges/description/
topics:
  - array
recommended: true
---
## Описание

Даётся отсортированный массив `nums` с уникальными числами. Диапазон `[a, b]` это множество всех чисел с `a` и до `b` включительно.

Вернуть наименьший отсортированный список диапазонов, который покрывает все числа в массиве. Каждый элемент в `nums` покрывается только одним диапазоном.

Каждый диапазон `[a,b]` в списке должен быть представлен как:

- `a -> b`, если `a !== b`;
- `a`, если `a == b`

---
## Ограничения

- `0 <= nums.length <= 20`
- `-2^31 <= nums[i] <= 2^31 - 1`
- Все значение в `nums` are уникальные.
- `nums` отсортирован в возрастающем порядке.

---
## Пример 1

### Входные данные

```
nums = [0,1,2,4,5,7]
```
### Выходные данные

```
["0->2","4->5","7"]
```
### Объяснение

```
The ranges are:
[0,2] --> "0->2"
[4,5] --> "4->5"
[7,7] --> "7"
```

---
## Пример 2

### Входные данные

```
nums = [0,2,3,4,6,8,9]
```
### Выходные данные

```
["0","2->4","6","8->9"]
```
### Объяснение

```
The ranges are:
[0,0] --> "0"
[2,4] --> "2->4"
[6,6] --> "6"
[8,9] --> "8->9"
```

---
## Решение 1

Смысл заключается в том, что мы храним начало диапазона (сначала это первый элемент массиве). Цикл начинает со второго элемента, чтобы можно было сравнить с предыдущим элементов. Внутри цикла мы смотрим на текущий элемент и предыдущий, если они отличаются ровно на `1`, то пропускаем итерацию. Иначе мы смотрим, а совпадает ли предыдущий элемент и `rangeStart`, если да, то заносим только один элемент, если нет, то заносим оба, не забываем обновить начала диапазона на новый элемент. Также отдельно нужно обработать последний сегмент. Все также, если последний элемент совпадает с началом диапазона, заносим один элемент, если не совпадает, то оба.

```typescript
const summaryRanges = (nums: number[]): string[] => {
  const output = [];

  if (nums.length === 0) return [];

  let rangeStart = nums[0];

  for (let i = 1; i < nums.length; i += 1) {
    if (nums[i] - nums[i - 1] === 1) continue;

    if (rangeStart === nums[i - 1]) {
      output.push(`${rangeStart}`);
    } else {
      output.push(`${rangeStart}->${nums[i - 1]}`);
    }

    rangeStart = nums[i];
  }

  if (nums.at(-1) === rangeStart) {
    output.push(`${rangeStart}`);
  } else {
    output.push(`${rangeStart}->${nums.at(-1)}`);
  }

  return output;
};
```

Сложность по времени: `O(n)`.

Сложность по памяти: `O(n)`.