---
level: easy
tags:
  - leetcode
linkToTask: https://leetcode.com/problems/can-place-flowers/description/?envType=study-plan-v2&envId=leetcode-75
topics:
  - array
recommended: true
---
## Описание

Даётся длинная клумба цветов на некоторых участках есть цветы, а некоторые пустые. Цветы не могут быть расположены на соседних участках, между ними должен быть как минимум один пустой участок.

Даётся массив `flowerbed`, который содержит `0` и `1`, где `0` - пустой участок, `1` - участок с цветком и целое число `n`. Нужно вернуть `true`, если `n` новых цветов можно посадить в клумбе, не нарушая правила "смежных цветов" и `false` в противном случае.

---
## Ограничения

- `1 <= flowerbed.length <= 2 * 10^4`
- `flowerbed[i]` либо `0`, либо `1`.
-  В `flowerbed` нет двух соседних цветков.
- `0 <= n <= flowerbed.length`

---
## Пример 1

### Входные данные

```
flowerbed = [1,0,0,0,1], n = 1
```
### Выходные данные

```
true
```

---
## Пример 2

### Входные данные

```
flowerbed = [1,0,0,0,1], n = 2
```
### Выходные данные

```
false
```

---

## Не решение

Сначала была идея смотреть на текущий участок, если он равняется `1`, то проверять можно ли садить цветок в участок через `1`, но этот алгоритм не покрывает случай, когда весь участок пуст.

---
## Решение 1

Проходимся по каждому участку и смотрим на текущий. Если он равен `0`, то смотрим на его соседей. Левый сосед должен равняться `0`, либо левого соседа может не быть, если это начало массива. Правый сосед тоже должен равняться `0`, либо его может не быть, если это конец массива.

```typescript
const canPlaceFlowers = (flowerbed: number[], n: number): boolean => {
  for (let i = 0; i < flowerbed.length; i += 1) {
    if (n === 0) return true;

    const left = flowerbed[i - 1] === 0 || i === 0;
    const right = flowerbed[i + 1] === 0 || i === flowerbed.length - 1;

    if (left && right && flowerbed[i] === 0) {
      flowerbed[i] = 1;

      n -= 1;
    }
  
  }

  return n === 0;
};
```

Сложность по времени: `O(n)`.

Сложность по памяти: `O(1)`.