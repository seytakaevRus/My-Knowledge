---
level: medium
tags:
  - leetcode
linkToTask: https://leetcode.ca/all/325.html
topics:
  - array
recommended: true
---
## Описание

Даётся массив чисел `nums` и число `k`, найти максимальную длину подмассива, чья сумма будет равна `k`, если такой нет, то вернуть `0`.

---
## Ограничения

- `1 <= nums.length <= 2 * 10^5`
- `-10^4 <= nums[i] <= 10^4`
- `-10^9 <= k <= 10^9`

---
## Пример 1

### Входные данные

```
nums = [1,-1,5,-2,3], k = 3
```
### Выходные данные

```
4
```
### Объяснение

```
The subarray [1, -1, 5, -2] sums to 3 and is the longest.
```

---
## Пример 2

### Входные данные

```
nums = [-2,-1,2,1], k = 1
```
### Выходные данные

```
2
```
### Объяснение

```
The subarray [-1, 2] sums to 1 and is the longest.
```

---
## Решение 1

Раз нужно найти длину подмассива с определённой суммой, то можно использовать технику [[Префиксная сумма#Пример 3|префиксная сумма]]. Техника `динамического скользящего окна` здесь не поможет, так как есть отрицательные числа и не понятно, когда двигать окно.

Принцип работы такой же, как и в примере по ссылке. Отнимаем от префиксной суммы `k` и смотрим, если такая сумма была встречена ранее, то подмассив с суммой `k` был встречен, поэтому вычисляем его длину и сравниваем с максимальной длинной. Если текущая сумма подмассива равна `k`, значит сравниваем с максимальной длинной. Также не забываем вносить текущую сумму в `map`, а в качестве ключа будет индекс последнего элемента, входящего в сумму. Важно отменить, если получились одинаковые префиксные суммы, то вносим только первую.

Рассмотрим пример:

`[-1, 1, 2, 3, -5, -1]` при `k = -1`, здесь есть два подмассива:

1. `[-1]`;
2. весь массив.

Раз нам нужна максимальная длина подмассива, то заносим только значение префиксной суммы.

```typescript
const maxSubArrayLen = (nums: number[], k: number): number => {
  const map = new Map();

  let maxLength = 0;
  let prefixSum = 0;

  for (let i = 0; i < nums.length; i += 1) {
    prefixSum += nums[i];

    const difference = prefixSum - k;

    if (prefixSum === k) {
      maxLength = Math.max(i + 1, maxLength);
    }

    if (map.has(difference)) {
      maxLength = Math.max(i - map.get(difference), maxLength);
    }

    if (!map.has(prefixSum)) {
      map.set(prefixSum, i);
    }
  }

  return maxLength;
};
```

Сложность по времени: `O(n)`.

Сложность по памяти: `O(n)`.