---
level: easy
tags:
  - leetcode
linkToTask: https://leetcode.com/problems/palindrome-linked-list/
topics:
  - single linked list
  - stack
recommended: true
---
## Описание

Дается `head` связного списка, вернуть `true`, если это палиндром или `false` в обратном случае.

Дополнительно: сделать за `O(n)` по времени и `O(1)` по памяти.

---
## Ограничения

- Количество узлов лежит в диапазоне `[1, 10^5]`.
- `0 <= Node.val <= 9`

---
## Пример 1

![[DSA_234_example_1.png]]

### Входные данные

```
head = [1,2,2,1]
```
### Выходные данные

```
true
```

---
## Пример 2

![[DSA_234_example_2.png]]

### Входные данные

```
head = [1,2]
```
### Выходные данные

```
false
```

---
## Решение 1

Заносим все значения списка в массив и с помощью техники [[Два указателя]] определяем, палиндром ли массив.

```typescript
const isPalindrome = (head: ListNode | null): boolean => {
  const array = [];

  for (let node = head; node !== null; node = node.next) {
    array.push(node.val);
  }

  for (let i = 0, j = array.length - 1; i < j; i += 1, j -= 1) {
    if (array[i] !== array[j]) return false; 
  }

  return true;
};
```

Сложность по времени: `O(n)`.

Сложность по памяти: `O(n)`.

---
## Решение 2

Чтобы сделать решение за `O(1)` по памяти, можно часть палиндрома, начиная с серединного узла и до конца списка, реверсировать. Затем с помощью указателей сравнивать элементы из двух частей (одна, которая находится в начале, а вторая, которая была реверсирована).

Если длина списка четная, то реверсирование с серединного узла сработает нормально, к примеру, `1 -> 2 -> 2 -> 1` превратится в `1 -> 2 -> 1 -> 2`. Однако, если длина нечетная, например, `1 -> 2 -> 1`, то список превратится в `1 -> 1 -> 2`, поэтому в этом случае нужно брать узел после серединного узла, и начиная с него реверсировать часть списка.

Чтобы реверсировать часть списка можно воспользоваться рецептом [[Реверсирование связного списка#Реверсирование части списка|Реверсирование части списка]]. Для этого нужно обнулить ссылку на узел, с которого начнется реверсирование, поэтому  нужно получить доступ к узлу перед серединным. Здесь можно использовать технику [[Быстрый и медленный указатель]].

```typescript
const isPalindrome = (head: ListNode | null): boolean => {
  if (head.next === null) return true;

  let slowPointer = head;
  let fastPointer = head.next.next;

  for (; fastPointer !== null && fastPointer.next !== null;) {
    slowPointer = slowPointer.next;
    fastPointer = fastPointer.next.next;
  }

  const middleNode = slowPointer.next;

  slowPointer.next = null;

  const startReverseNodeFrom = fastPointer === null ? middleNode : middleNode.next;

  const reversedHead = reverseNodes(startReverseNodeFrom);

  for (let node1 = head, node2 = reversedHead; node1 !== null && node2 !== null; node1 = node1.next, node2 = node2.next) {
    if (node1.val !== node2.val) return false;
  }

  return true;
};
```

Сложность по времени: `O(n)`.

Сложность по памяти: `O(1)`.

---
## Не решение

При попытке использования `стека` был придумал алгоритм:

1. Посчитать длину связного списка;
2. Определить является ли длина нечетной;
3. Определить индекс серединного узла, если длина нечетная;
4. Если длина нечетная и `i === индексу серединного узла`, то пропускаем итерацию
5. Если вершина на `стеке` имеет отличное значение от значения узла, то заносить в `стек`;
6. Если вершина на `стеке` имеет тоже значение, что и у узла, то убираем значение со `стека`.

Этот алгоритм определял является ли палиндромом такие связные списки, как:

- `1 -> 2 -> 1`;
- `1 -> 2 -> 2 -> 1`;
- `1 -> 1 -> 1 -> 1 ->`
- Но не `1 -> 2 -> 2 -> 3 -> 3 -> 1`, алгоритм оказался не верным, так как данный список не является палиндромом, алгоритм возвращает, что это палиндром.

---
## Решение 3

Сначала проходим по списку и заносим все значения в `стек`. Затем снова проходим по списку и каждое значение сравниваем с верхушкой `стека`, если они совпадают, то из `стека` убираем элемент. Если `стек` пустой, значит это `палиндром`.

Работает это потому, что перебор элементов в `стеке` возможен только с верхушки, а верхушка указывает на последний элемент списка, поэтому перебор происходит в реверсированном порядке для списка.

```typescript
const isPalindrome = (head: ListNode | null): boolean => {
  const stack = [];

  for (let node = head; node !== null; node = node.next) {
    stack.push(node.val);
  }

  for (let node = head; node !== null; node = node.next) {
    if (stack.at(-1) === node.val) {
      stack.pop();
    }
  }

  return stack.length === 0;
};
```

Сложность по времени: `O(n)`.

Сложность по памяти: `O(n)`.