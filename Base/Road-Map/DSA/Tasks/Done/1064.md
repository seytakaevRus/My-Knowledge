---
level: easy
tags:
  - leetcode
linkToTask: https://leetcode.ca/2018-10-29-1064-Fixed-Point/
topics:
  - array
recommended: true
---
## Описание

Дается массив уникальных чисел `arr`, где `arr` отсортирован в возрастающем порядке, вернуть минимальный индекс, который удовлетворяет условию `arr[i] === i`. Если такого индекса нет, то вернуть `-1`.

Дополнительно: сделать по времени лучше, чем `O(n)`.

---
## Ограничения

- `1 <= arr.length < 10^4`
- `-10^9 <= arr[i] <= 10^9`

---
## Пример 1

### Входные данные

```
arr = [-10,-5,0,3,7]
```
### Выходные данные

```
3
```
### Объяснение

```
For the given array, `arr[0] = -10, arr[1] = -5, arr[2] = 0, arr[3] = 3`, thus the output is 3.
```

---
## Пример 2

### Входные данные

```
arr = [0,2,5,8,17]
```
### Выходные данные

```
0
```
### Объяснение

```
arr[0] = 0, thus the output is 0.
```

---
## Решение 1

```typescript
const fixedPoint = (arr: number[]): number => {
  for (let i = 0; i < arr.length; i += 1) {
    if (arr[i] === i) {
      return i;
    }
  }

  return -1;
}
```

Сложность по времени: `O(n)`.

Сложность по памяти: `O(1)`.

---
## Решение 2

Здесь используется техника [[Бинарный поиск]].

Если индекс элемента равен самому элементу, то возвращаем этот индекс, тут все понятно. Поэтому рассмотрим условие выбора стороны. Так как все элементы в массиве уникальные, то если на `index` стоит элемент, который не равен `index`, то все элементы дальше `index` также не будут равны своему `index`, поэтому при `arr[middle] > middle` мы отбрасываем правую часть. Тоже самое касается и условия `arr[middle] < middle`, из-за условия уникальности элементов мы можем смело отбрасывать левую сторону.

```typescript
const fixedPoint = (arr: number[]): number => {
  let left = 0;
  let right = arr.length - 1;

  for (; left <= right; ) {
    const middle = Math.floor((left + right) / 2);

    if (arr[middle] === middle) return middle;

    if (middle > arr[middle]) {
      left = middle + 1;
    } else {
      right = middle - 1;
    }
  }

  return -1;
};
```

Сложность по времени: `O(log n)`.

Сложность по памяти: `O(1)`.