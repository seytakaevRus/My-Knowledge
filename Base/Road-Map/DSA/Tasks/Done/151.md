---
level: medium
tags:
  - leetcode
linkToTask: https://leetcode.com/problems/reverse-words-in-a-string/description/?envType=study-plan-v2&envId=leetcode-75
topics:
  - string
recommended: true
---
## Описание

Даётся строка `s`, реверсировать порядок `слов` в строке.

`Слово` - определяется как последовательность не пробельных символов. `Слова` в строке `s` разделены как минимум одним пробелом.

Вернуть строку, где порядок слов был реверсирован, причём слова разделены по пробелу.

Пробелов может быть сколько угодно в начале строки, в конце строки и между словами.

Дополнительно: если бы в твоём языке можно было мутировать строки, то напиши алгоритм за `O(1)` по памяти.

---
## Ограничения

- `1 <= s.length <= 10^4`
- `s` содержит английские буквы (верхнего регистра, нижнего регистра), цифры, и пробелы `' '`.
- Есть как минимум одно слово в `s`.

---
## Пример 1

### Входные данные

```
s = "the sky is blue"
```
### Выходные данные

```
"blue is sky the"
```

---
## Пример 2

### Входные данные

```
s = "a good   example"
```
### Выходные данные

```
"example good a"
```
### Объяснение

```
You need to reduce multiple spaces between two words to a single space in the reversed string.
```

---

## Решение 1

Сначала избавляемся от всех пробелов через разделение строки по пробелу. В таком массиве останутся пустые строки и слова, тогда используем фильтрацию с `Boolean`, так как пустая строка преобразуется к `false` и будет скипнута. Далее реверсируем массив и соединяем по пробелу.

```typescript
const reverseWords = (s: string): string => {
  return s
    .split(' ')
    .filter(Boolean)
    .reverse()
    .join(' ');
};
```

Сложность по времени: `O(n)`.

Сложность по памяти: `O(n)`.

---
## Решение 2

Идея заключается в том, чтобы достать все слова в `output`, а далее реверсирование и соединение по пробелу. Если `word` не пуст, то мы уже начали собирать по буквам слово. Если слово не пусто, и текущий символ это пробел, значит мы закончили собирать текущее слово, кидаем его в `output`.

```typescript
const reverseWords = (s: string): string => {
  const output = [];

  let word = "";

  for (let i = 0; i < s.length; i += 1) {
    if (s[i] === " " && word === "") continue;
    if (s[i] === " " && word !== "") {
      output.push(word);

      word = "";

      continue;
    }

    word += s[i];
  }

  if (word !== "") {
    output.push(word);
  }

  return output.reverse().join(' ');
};
```

Сложность по времени: `O(n)`.

Сложность по памяти: `O(n)`.

---
## Решение 3

Так как в `JS` можно изменять строку только через создание новой строки, то за `O(1)` по времени задачу сделать нельзя. Поэтому для имитации мутируемости строчки она была превращена в массив. Также, чтобы превратить из массива в строку нужна также память, а в остальном алгоритм работает только с "строкой" `output`.

Идея заключается в следующем:

1. Реверсировать всю строку;
2. Реверсировать каждое слово;
3. Сместить все слова в начало, а лишние пробелы в конец;
4. Обрезать строку, чтобы удалить лишние пробелы.

С первым пунктом всё понятно.

Для второго пункта используется техника [[Два указателя]], они будут обозначать границы слова. Поэтому в первом внешнем цикле ищем начало слова, заносим его в `left`. Далее ищем конец слова, двигая индекс `i`, так как он будет указывать на следующий символ после конца слова, то отнимает от него `1` и заносим в `right`. Далее реверсируем слово, двигая указатели.

Далее заводится указатель `writePointer`, отвечающий за запись символов. Также нужен флаг `isSwapWasStarted`, который показывает был ли начат обмен символами. Здесь есть три сценария:

1. Обмен не был начат и текущий символ является пробелом, в таком случае ничего не делаем;
2. Обмен не был начат и текущий символ это не пробел, тогда начинаем обмен символами на левом и на правом указателе, обновляем `trueSentenceEnd`, который отвечает за позицию конца новой строки, благодаря этой переменной в четвертом пункте можно будет обрезать строку;
3. Обемн был начата и текущий символ это пробел, здесь прекращаем обмен, вставляем пробел в на текущее значение указателя и увеличиваем значение указателя.

В четвёртом пункте обрезаем массив, и собираем через `join`.

```typescript
const reverseWords = (s: string): string => {
  const output = s.split('').reverse();

  let left = 0;
  let right = 0;

  for (let i = 0; i < output.length; i += 1) {
    if (output[i] === " ") continue;

    left = i;

    for (; output[i] !== " "; i += 1) {
      if (i >= output.length) break;
    }

    right = i - 1;

    for (; left < right;) {
      [output[left], output[right]] = [output[right], output[left]];

      left += 1;
      right -= 1;
    }
  }

  let isSwapWasStarted = false;
  let writePointer = 0;
  let trueSentenceEnd = 0;

  for (let i = 0; i < output.length; i += 1) {
    if (output[i] !== " ") {
      isSwapWasStarted = true;

      [output[writePointer], output[i]] = [output[i], output[writePointer]];

      trueSentenceEnd = writePointer;

      writePointer += 1;
    } else if (isSwapWasStarted && output[i] === " ") {
      isSwapWasStarted = false;

      output[writePointer] = " ";

      writePointer += 1;
    }
  }

  return output.slice(0, trueSentenceEnd + 1).join('');
};
```

Сложность по времени: `O(n * m)`, где `n` - длина `s`, `m` - длина слова.

Сложность по памяти: `O(n)`.