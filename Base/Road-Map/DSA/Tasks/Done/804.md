---
level: easy
tags:
  - leetcode
linkToTask: https://leetcode.com/problems/unique-morse-code-words/
topics:
  - array
  - hash table
recommended: false
---
## Описание

Дается массив строк `strings`, где каждое слово может быть представлено, как строка, где каждая буква это код Морзе.

Вернуть количество уникальных трансформаций слова в последовательность Морзе.

Дополнительно: в массиве ниже указана расшифровка каждой буквы английского алфавита в код Морзе.
`const array = [".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."]`.

---
## Ограничения

- `1 <= words.length <= 100`
- `1 <= words[i].length <= 12`
- `words[i]` содержит только буквы английского алфавита в нижнем регистре.

---
## Пример 1

### Входные данные

```
words = ["gin","zen","gig","msg"]
```
### Выходные данные

```
2
```
### Объяснение

```
The transformation of each word is:
"gin" -> "--...-."
"zen" -> "--...-."
"gig" -> "--...--."
"msg" -> "--...--."
There are 2 different transformations: "--...-." and "--...--.".
```

---
## Пример 2

### Входные данные

```
words = ["a"]
```
### Выходные данные

```
1
```

---
## Решение 1

Подсчитать количество уникальных ключей можно при помощи `Set`. Также вначале создается `morseMap` для удобства перевода буквы в код.

```typescript
const uniqueMorseRepresentations = (words: string[]): number => {
  const morseMap = { 'a': ".-", 'b': "-...", 'c': "-.-.", 'd': "-..", 'e': ".", 'f': "..-.", 'g': "--.", 'h': "....", 'i': "..", 'j': ".---", 'k': "-.-", 'l': ".-..", 'm': "--", 'n': "-.", 'o': "---", 'p': ".--.", 'q': "--.-", 'r': ".-.", 's': "...", 't': "-", 'u': "..-", 'v': "...-", 'w': ".--", 'x': "-..-", 'y': "-.--", 'z': "--.." };
  const uniqueMorse = new Set();

  words.forEach((word) => {
    let morse = '';

    for (const letter of word) {
      morse += morseMap[letter];
    }

    uniqueMorse.add(morse);
  });

  return uniqueMorse.size;
};
```

Сложность по времени: `O(n * m)`, где `n` - количество слов, а `m` - количество букв в слове.

Сложность по памяти: `O(k)`, где `k` - количество уникальных слов в последовательности Морзе.