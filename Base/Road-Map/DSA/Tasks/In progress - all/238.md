---
level: 
tags:
  - leetcode
linkToTask: 
topics: 
recommended: true
---
## Описание

---
## Ограничения

---
## Пример 1

### Входные данные

```

```
### Выходные данные

```

```
### Объяснение

```

```

---
## Пример 2

### Входные данные

```

```
### Выходные данные

```

```
### Объяснение

```

```

---
## Не решение

```typescript
const productExceptSelf = (nums: number[]): number[] => {
  const output = [];

  let productExceptZero = 1;
  let countOfZeros = 0;

  nums.forEach((value) => {
    if (value !== 0) {
      productExceptZero *= value;
    } else {
      countOfZeros += 1;
    }
  });

  for (let i = 0; i < nums.length; i += 1) {
    if (countOfZeros === 1) {
      if (nums[i] !== 0) {
        output.push(0);
      } else {
        output.push(productExceptZero);
      }
    } else if (countOfZeros > 1) {
      output.push(0);
    } else {
      if (i > 0) {
        productExceptZero *= nums[i - 1]
      }

      productExceptZero /= nums[i];

      output.push(productExceptZero);
    }
  }

  return output;
};
```

---
## Решение 1

```typescript
const productExceptSelf = (nums: number[]): number[] => {
  const output = [];
  const prefix = [];
  const suffix = [];

  let prefixProduct = 1;
  let suffixProduct = 1;

  for (let i = 0; i < nums.length; i += 1) {
    prefixProduct *= nums[i - 1] ?? 1;

    prefix[i] = prefixProduct;
  }

  for (let i = nums.length - 1; i >= 0; i -= 1) {
    suffixProduct *= nums[i + 1] ?? 1;

    suffix[i] = suffixProduct;
  }

  for (let i = 0; i < nums.length; i += 1) {
    output.push(prefix[i] * suffix[i])
  }

  return output;
};
```

Сложность по времени: `O()`.

Сложность по памяти: `O()`.

---
## Решение 2

```typescript
const productExceptSelf = (nums: number[]): number[] => {
  const output = new Array(nums.length).fill(1);

  let prefixProduct = 1;
  let suffixProduct = 1;

  for (let i = 1; i < nums.length; i += 1) {
    prefixProduct *= nums[i - 1];

    output[i] *= prefixProduct;
  }

  for (let i = nums.length - 2; i >= 0; i -= 1) {
    suffixProduct *= nums[i + 1];

    output[i] *= suffixProduct;
  }

  return output;
};
```

Сложность по времени: `O()`.

Сложность по памяти: `O()`.