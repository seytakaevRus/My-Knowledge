---
level: medium
tags:
  - leetcode
linkToTask: https://leetcode.com/problems/asteroid-collision/description/?envType=study-plan-v2&envId=leetcode-75
topics:
  - array
  - stack
  - simulation
recommended: true
---
## Описание

Даётся массив `asteroids`, который представляет из себя последовательность астероидов в строке.

Для каждого астероида абсолютное значение представляет его размер, а знак представляет его направление (`+` означает вправо, `-` означает влево). Каждый астероид движется с одинаковой скоростью.

Нужно вычислить какие астероиды останутся после всех столкновений. Если два астероида встретятся, меньший из них взорвется. Если оба астероида одинакового размера, оба взорвутся. Два астероида, движущиеся в одном направлении, никогда не встретятся.

---
## Ограничения

- `2 <= asteroids.length <= 10^4`
- `-1000 <= asteroids[i] <= 1000`
- `asteroids[i] != 0`

---
## Пример 1

### Входные данные

```
asteroids = [5,10,-5]
```
### Выходные данные

```
[5,10]
```
### Объяснение

```
The 10 and -5 collide resulting in 10. The 5 and 10 never collide.
```

---
## Пример 2

### Входные данные

```
asteroids = [10,2,-5]
```
### Выходные данные

```
[10]
```
### Объяснение

```
The 2 and -5 collide resulting in -5. The 10 and -5 collide resulting in 10.
```

---
## Решение 1

Это решение не совсем соответствует структуре `стек`, так как тут идёт обращение к предпоследнему элементу `стека`. 

Для начала элемент заносится в `стек`. Если предпоследний элемент больше `0` (астероид летит вправо), а последний элемент меньше `0` (астероид летит влево), то запускается цикл, где рассматриваются разные кейсы, для простоты получается сумма значений астероидов:

1. Если сумма равна `0` (значения одинаковые, разница только в знаке), то они оба удаляются из `стека`;
2. Если сумма больше `0` (значение предпоследнего по модулю оказалось больше, чем предпоследнего), то удаляется только последний;
3. Если сумма меньше `0` (значение последнего по модулю оказалась больше, чем предпоследнего), то удаляются оба и заносится текущий астероид (который был последним в `стеке`).

```typescript
const asteroidCollision = (asteroids: number[]): number[] => {
  const stack = [];

  for (const asteroid of asteroids) {
    stack.push(asteroid);

    for (; stack.at(-2) > 0 && stack.at(-1) < 0 ;) {
      const sum = stack.at(-2) + stack.at(-1);

      if (sum === 0) {
        stack.pop();
        stack.pop();
      } else if (sum > 0) {
        stack.pop();
      } else {
        stack.pop();
        stack.pop();
        stack.push(asteroid);
      }
    }
  }

  return stack;
};
```

Сложность по времени: `O(n)`.

Сложность по памяти: `O(n)`.

---
## Решение 2

Это решение полностью соответствует структуре `стек`. Смысл заключается в том, чтобы сравнивать последний элемент на `стеке` и текущий астероид:

1. Если `стек` пустой или последний астероид в `стеке` меньше `0`, или текущий астероид больше `0`, то просто кладём астероид в `стек` и завершаем итерацию. Столкновения возможно только тогда, когда слева находится астероид, который движется вправо (`+`), а вправо астероид, который движется влево (`-`);
2. Если значение последнего астероида в `стеке` и текущего астероида равны по модулю, то убираем из `стека` астероид и завершаем итерацию;
3. Если же выполняется условие столкновения (пункт `1`) и текущий астероид по модулю больше, чем последний в `стеке`, то удаляем последний от туда и понижаем индекс на `1`. Так как в цикле после каждой итерации индекс повышается на `1`, то индекс останется на месте, а значит будет указывать на тот же астероид, но последний элемент в `стеке` будет уже другим. Благодаря этой хитрости можно циклично удалять астероиды из `стека`, чьё значение по модулю будет меньше текущего астероида. А если такие астероиды закончатся, то будут выполняться два условия из `1` пункта (`стек` пустой или последний элемент в `стеке` меньше `0`).
4. Также есть кейс, когда выполняется условие `3` пункта, но последний астероид в `стеке` по модулю больше, чем текущий астероид. В этом случае нужно просто не учитывать текущий астероид и увеличить индекс, поэтому этот кейс не обрабатывается явно.

```typescript
const asteroidCollision = (asteroids: number[]): number[] => {
  const stack = [];

  for (let i = 0; i < asteroids.length; i += 1) {
    const asteroid = asteroids[i];

    if (stack.length === 0 || stack.at(-1) < 0 || asteroid > 0) {
      stack.push(asteroid);

      continue;
    }

    if (stack.at(-1) === -asteroid) {
      stack.pop();

      continue;
    }

    if (stack.at(-1) > 0 && asteroid < 0 && stack.at(-1) < Math.abs(asteroid)) {
      stack.pop();

      i -= 1;
    }

  }

  return stack;
};
```

Сложность по времени: `O(n)`.

Сложность по памяти: `O(n)`.