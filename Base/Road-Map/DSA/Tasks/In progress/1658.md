---
level: medium
tags:
  - leetcode
linkToTask: https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/description/
topics:
  - array
  - hashmap
recommended: true
---
## Описание

TODO: Решить при помощи `prefix-sum`

Дается массив из чисел `nums` и число `x`. За одну операцию можно либо удалить значение с начала, либо значение с конца и вычесть его из `x`. Эти операции изменяют массив для будущих операций.

Вернуть минимальное количество операций, чтобы `x` стал равен точно `0`, если это возможно, иначе вернуть `-1`.

---
## Ограничения

- `1 <= nums.length <= 10^5`
- `1 <= nums[i] <= 10^4`
- `1 <= x <= 10^9`

---
## Пример 1

### Входные данные

```
nums = [1,1,4,2,3], x = 5
```
### Выходные данные

```
2
```
### Объяснение

```
The optimal solution is to remove the last two elements to reduce x to zero.
```

---
## Пример 2

### Входные данные

```
nums = [5,6,7,8,9], x = 4
```
### Выходные данные

```
-1
```

---
## Решение 1

Раз речь идет про подмассив, то нужно использовать `Скользящее окно`, но длина окна неизвестна, поэтому нужен вариант [[Скользящее окно#Динамический размер|Скользящее окно динамического размера]].

Нам нужен найти минимальное количество операций, чтобы `x` стало ровно нулем, причем удалять можно только с начала или только с конца, значит нужно найти минимальной длины подмассив, чьи элементы в сумме давали бы `x`. Но этот подмассив должен быть образовывать подмассив с элементом, который стоит в начале массиве или в его конце, а этого добиться непросто.

Значит задачу можно сформировать по-другому, нужно найти максимальную подпоследовательность, чья сумма будет равна `сумма всех элементов в массиве nums - x`.

Одним из граничных случаев является случай, когда `x` равен сумме всех элементов в массиве `nums`, если это произошло, то нужно вернуть длину массива `nums`.

Сравнение размера окна и максимальной длинны должно производиться, когда сумма текущего окна равна `сумме всех элементов - x`.

Если не был обнаружен подмассив, который давал бы нужную сумму элементов, то `maxLength` будет равен `0`, в таком случае возвращаем `-1`.

```typescript
const minOperations = (nums: number[], x: number): number => {
  const numsSum =  nums.reduce((acc, value) => acc + value);
  const sumToFind = numsSum - x;

  let sum = 0;
  let maxLength = 0;
  let windowSize = 0;

  let leftEdge = 0;

  if (sumToFind === 0) return nums.length;

  for (let rightEdge = 0; rightEdge < nums.length; rightEdge += 1) {
    windowSize += 1;

    sum += nums[rightEdge];

    for (;sum >= sumToFind;) {
      if (sum === sumToFind) maxLength = Math.max(windowSize, maxLength);

      windowSize -= 1;

      sum -= nums[leftEdge];

      leftEdge += 1;
    }
  }

  return maxLength === 0 ? -1 : nums.length - maxLength;
};
```

Сложность по времени: `O(n)`.

Сложность по памяти: `O(1)`.

---
## Решение 2

```typescript

```

Сложность по времени: `O()`.

Сложность по памяти: `O()`.

---
## Связанное

- [[1423|Maximum Points You Can Obtain from Cards]]