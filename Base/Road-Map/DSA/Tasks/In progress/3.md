---
level: 
tags:
  - leetcode
linkToTask: https://leetcode.com/problems/longest-substring-without-repeating-characters/description/?source=submission-noac
topics:
---
## Описание

---
## Ограничения

---
## Пример 1

### Входные данные

```

```
### Выходные данные

```

```
### Объяснение

```

```

---
## Пример 2

### Входные данные

```

```
### Выходные данные

```

```
### Объяснение

```

```

---
## Решение 1

Здесь используется техника [[Скользящее окно#Динамический размер|Скользящее окно динамического размера]], потому что известна длина окна неизвестна.

```typescript
const lengthOfLongestSubstring = (s: string): number => {
  if (s.length === 0) return 0;

  const map = new Map();

  let maxLength = 1;
  let currentLength = 1
  let leftPointer = 0;
  let rightPointer = 1;

  map.set(s[leftPointer], 1);

  for (; rightPointer < s.length;) {
    if (map.has(s[rightPointer])) {
      map.delete(s[leftPointer]);

      leftPointer += 1;
      currentLength -= 1;
    } else {
      map.set(s[rightPointer], 1);

      rightPointer += 1;
      currentLength += 1;
    }

    maxLength = Math.max(currentLength, maxLength);
  }

  return maxLength;
};
```

Сложность по времени: `O()`.

Сложность по памяти: `O()`.

---
## Решение 2

Здесь используется техника [[Скользящее окно#Динамический размер|Скользящее окно динамического размера]], потому что известна длина окна неизвестна.

```typescript
const lengthOfLongestSubstring = (s: string): number => {
  if (s.length === 0) return 0;

  const map = new Map();

  let maxLength = Number.MIN_SAFE_INTEGER;
  let startWindow = 0;

  for (let endWindow = 0; endWindow < s.length; endWindow += 1) {
    incrementElementFrequencyInMap(map, s[endWindow]);

    for (; map.size !== endWindow - startWindow + 1;) {
      decrementElementFrequencyInMap(map, s[startWindow]);

      startWindow += 1;
    }

    maxLength = Math.max(map.size, maxLength);
  }

  return maxLength;
};
```

Сложность по времени: `O()`.

Сложность по памяти: `O()`.

---
## Связанное

- 