---
level: medium
tags:
  - leetcode
linkToTask: https://leetcode.com/problems/sliding-subarray-beauty/description/
topics:
  - array
  - hashmap
---
## Описание

Дается массив чисел `nums`, который содержит `n` чисел, найти `красоту` каждого подмассива размером `k`.

`Красота` подмассива это `x-ное` самое маленькое число в подмассиве, если оно отрицательное и `0`, если это число не отрицательное.

Вернуть массив чисел, которые содержат `n - k + 1` чисел, которые обозначают `красоту` каждого подмассива.

---
## Ограничения

- `n == nums.length` 
- `1 <= n <= 10^5`
- `1 <= k <= n`
- `1 <= x <= k` 
- `-50 <= nums[i] <= 50`

---
## Пример 1

### Входные данные

```
nums = [1,-1,-3,-2,3], k = 3, x = 2
```
### Выходные данные

```
[-1,-2,-2]
```
### Объяснение

```
There are 3 subarrays with size k = 3. 
The first subarray is `[1, -1, -3]` and the 2nd smallest negative integer is -1. 
The second subarray is `[-1, -3, -2]` and the 2nd smallest negative integer is -2. 
The third subarray is `[-3, -2, 3]` and the 2nd smallest negative integer is -2.
```

---
## Пример 2

### Входные данные

```
nums = [-3,1,2,-3,0,-3], k = 2, x = 1
```
### Выходные данные

```
[-3,0,-3,-3,-3]
```
### Объяснение

```
There are 5 subarrays with size k = 2**.**
For `[-3, 1]`, the 1st smallest negative integer is -3.
For `[1, 2]`, there is no negative integer so the beauty is 0.
For `[2, -3]`, the 1st smallest negative integer is -3.
For `[-3, 0]`, the 1st smallest negative integer is -3.
For `[0, -3]`, the 1st smallest negative integer is -3.
```

---
## Не решение 1

```typescript
const getSingleBeautyOfSubarray = (subarray: number[], x: number) => {
  subarray.sort((a, b) => a - b);

  return subarray[x - 1] < 0 ? subarray[x - 1] : 0;
}

const getSubarrayBeauty = (nums: number[], k: number, x: number): number[] => {
  const output: number[] = [];

  for (let i = 0; i <= nums.length - k; i += 1) {
    const beauty = getSingleBeautyOfSubarray(nums.slice(i, i + k), x);

    output.push(beauty);
  }

  return output;
};
```

---
## Не решение 2

```typescript
const getSingleBeautyFromSubarray = (hashMap: Record<string, number>, x: number): number => {
  let smallestIntegersCount = 0;
  let iOccurencesCount = 0;

  for (let i = -50; i < 0;) {
    if (hashMap[i] !== undefined && hashMap[i] !== iOccurencesCount) {
      smallestIntegersCount += 1;
      iOccurencesCount += 1;

      if (smallestIntegersCount === x) return i;
    } else {
      i += 1

      iOccurencesCount = 0;
    }
  }

  return 0;
} 

const getSubarrayBeauty = (nums: number[], k: number, x: number): number[] => {
  const hashMap = {};
  const output = [];

  for (let i = 0; i < k; i += 1) {
    if (hashMap[nums[i]] === undefined) {
      hashMap[nums[i]] = 0;
    }
    
    hashMap[nums[i]] += 1;
  }

  const beauty = getSingleBeautyFromSubarray(hashMap, x);

  output.push(beauty);

  for (let i = k; i < nums.length; i += 1) {
    hashMap[nums[i - k]] -= 1;

    if (hashMap[nums[i - k]] === 0) {
      delete hashMap[nums[i - k]];
    }

    if (hashMap[nums[i]] === undefined) {
      hashMap[nums[i]] = 0;
    }
    
    hashMap[nums[i]] += 1;

    const beauty = getSingleBeautyFromSubarray(hashMap, x);

    output.push(beauty);
  }

  return output;
};
```

---
## Не решение 3

```typescript
const getSingleBeautyFromSubarray = (hashMap: Record<string, number>, x: number): number => {
  let smallestIntegersCount = 0;

  for (let i = -50; i < 0;) {
    if (hashMap[i] !== undefined) {
      smallestIntegersCount += hashMap[i];

      if (smallestIntegersCount >= x) return i;
    }

    i += 1;
  }

  return 0;
} 

const getSubarrayBeauty = (nums: number[], k: number, x: number): number[] => {
  const hashMap: Record<string, number> = {};
  const output: number[] = [];

  for (let i = 0; i < k; i += 1) {
    if (hashMap[nums[i]] === undefined) {
      hashMap[nums[i]] = 0;
    }
    
    hashMap[nums[i]] += 1;
  }

  const beauty = getSingleBeautyFromSubarray(hashMap, x);

  output.push(beauty);

  for (let i = k; i < nums.length; i += 1) {
    hashMap[nums[i - k]] -= 1;

    if (hashMap[nums[i - k]] === 0) {
      delete hashMap[nums[i - k]];
    }

    if (hashMap[nums[i]] === undefined) {
      hashMap[nums[i]] = 0;
    }
    
    hashMap[nums[i]] += 1;

    const beauty = getSingleBeautyFromSubarray(hashMap, x);

    output.push(beauty);
  }

  return output;
};
```

---
## Решение 1

```typescript
const getSingleBeautyFromSubarray = (map: any, x: number): number => {
  let countOfSmallestIntegers = 0;

  for (let i = -50; i < 0; i += 1) {
    if (map.has(i)) {
      countOfSmallestIntegers += map.get(i);

      if (countOfSmallestIntegers >= x) return i;
    }
  }

  return 0;
};

const getSubarrayBeauty = (nums: number[], k: number, x: number): number[] => {
  const map = new Map();
  const output = [];

  for (let i = 0; i < k; i += 1) {
    if (map.has(nums[i])) {
      map.set(nums[i], map.get(nums[i]) + 1);
    } else {
      map.set(nums[i], 1);
    }
  }

  const beauty = getSingleBeautyFromSubarray(map, x);

  output.push(beauty);

  for (let i = k; i < nums.length; i += 1) {
    if (map.get(nums[i - k]) === 1) {
      map.delete(nums[i - k]);
    } else {
      map.set(nums[i - k], map.get(nums[i - k]) - 1);
    }

    if (map.has(nums[i])) {
      map.set(nums[i], map.get(nums[i]) + 1);
    } else {
      map.set(nums[i], 1);
    }

    const beauty = getSingleBeautyFromSubarray(map, x);

    output.push(beauty);
  }

  return output;
};
```

Сложность по времени: `O(n)`.

Сложность по памяти: `O(k)`.

---
## Решение 2

```typescript

```

Сложность по времени: `O()`.

Сложность по памяти: `O()`.

---
## Связанное

- 