---
tags:
  - leetcode
  - mechanic
---
## Описание

Механика, описанная здесь позволяет представить строку, состоящую из английских букв, как массив длиною `26`, где на `0` индекса располагается частота встречаемости буквы `a`, а на `25` индексе букву `z`.

Чтобы вычислить позицию буквы в таком массиве берется её код с помощью метода `String.prototype.charCodeAt(0)` и отнимается `97`, так как код буквы `a` равняется `97`.

---
## Ограничения

- метод используется в основном для английских букв, там коды букв в таблице кодировки идут последовательно, к примеру, в русском языке код буквы `е` равняется `1077`, а буквы `ё` равняется `1105`.

---
## Преимущества

- в некоторых задач очень упрощает создание алгоритма;
- позволяет снизить сложность по памяти к `O(1)`, так как длина массива никак не зависит от длины строки.

---
## Использование

На вход подается строка `s`, в которой содержатся буквы английского алфавита в нижнем регистре. Нужно найти букву, которая раньше всех встречается дважды.

```typescript

```

---
## Задачи, с применением техники

```dataviewjs
const currentFileName = dv.current().file.name;

dv.table(["Task"], dv.pages('#leetcode')
	.filter(entity => {
		const linkArray = dv.array(entity.file.outlinks.values);
		return linkArray.some(link => link.path.includes(currentFileName));
	})
	.map(entity => {
		return [entity.file.link];
	}));
```