---
tags:
  - leetcode
  - mechanic
---
## Описание

Циклическая сортировка - алгоритм, который сортирует массив целых чисел на месте. Подходит для массивов, чьи элементы расположены в диапазоне `[0..n]` или `[1..n]`, в последнем случае для вычисления `correntIndex` добавляется `-1`.

Идея в том, чтобы по значению элемента определять, нужный индекс, на который это значение и станет.

---
## Ограничения

- массив со значениями должен быть в диапазоне `[1..n]`;
- элементы в массиве должны быть уникальными.

---
## Преимущества

- не выделяет дополнительную память при сортировке, так как сортирует массив на месте, поэтому сложность по памяти `O(1)`;
- сложность по времени составляет `O(n)`.

---
## Использование

Как говорилась выше, мы ставим элемент на нужный индекс, исходя из его значения. К примеру, элемент со значением `5` должен будет встать:
- на индекс `5`, если это диапазон `[0..n]`;
-  и на индекс `4`, если это диапазон `[1..n]`.

Поэтому `index` не меняется до тех пор, пока `array[index]` не будет равен:
- `array[array[index]]`, если диапазон `[0..n]`;
- или `array[array[index]] - 1`, если диапазон `[1..n]`.

```typescript
const cycleSort = (array: number[]): number[] => {
  for (let index = 0; index < array.length;) {
    const elementByIndex = array[index] - 1;

    if (array[index] !== array[elementByIndex]) {
      [array[index], array[elementByIndex]] = [array[elementByIndex], array[index]];
    } else {
      index += 1;
    }
  }

  return nums;
};
```

Если в массиве есть только уникальные элементы, то можно условие `array[index] !== array[elementByIndex]` заменить на `index !== elementByIndex`.

В ограничениях написано, что элементы должны быть уникальные, но это не совсем так. Даже при наличии дублей, можно использовать сортировку, но она будет больше использована для поиска дубликатов, а не для сортировки.

Есть массив с дубликатами ниже.

```ts
const array = [1, 1, 1, 2, 3, 4, 5];
```

Если его прогнать через функцию `cyclicSort`, то массив станет таким:

```ts
[1, 2, 3, 4, 5, 1, 1]
```

Уникальные элементы встали на свои места, а дубликаты просто сместились.

---
## Задачи, с применением техники

```dataviewjs
const currentFileName = dv.current().file.name;

dv.table(["Task"], dv.pages('#leetcode')
	.filter(entity => {
		const linkArray = dv.array(entity.file.outlinks.values);
		return linkArray.some(link => link.path.includes(currentFileName));
	})
	.map(entity => {
		return [entity.file.link];
	}));
```