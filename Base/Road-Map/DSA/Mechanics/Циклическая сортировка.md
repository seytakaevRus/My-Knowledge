---
tags:
  - leetcode
  - mechanic
---
## Описание

Циклическая сортировка - алгоритм, который сортирует массив целых чисел на месте. Подходит для массивов, чьи элементы расположены в диапазоне `[0..n]` или `[1..n]`, в последнем случае для вычисления `correntIndex` добавляется `-1`.

Идея состоит в том, что бы по значению элемента определять, на какой индекс нужно ставить элемент.

---
## Ограничения

- массив со значениями должен быть в диапазоне `[1..n]`;
- элементы в массиве должны быть уникальными.

---
## Преимущества

- не выделяет дополнительную память при сортировке, так как сортирует массив на месте, поэтому сложность по памяти `O(1)`;
- сложность по времени составляет `O(n)`.

---
## Использование

`index` не меняется, пока на число, значение которого равно `nums[index]` не встанет на свое место.  со значением `array[index] + 1` при `[1..n]` и со значением `array[index]` при `[0..n]`. Чтобы это произошло меняются местами элементы с индексом `correctIndex` и `index`.

```typescript
const cycleSort = (nums: number[]): number[] => {
  for (let index = 0; index < nums.length;) {
    const elementByIndex = nums[index] - 1;

    if (nums[index] !== nums[elementByIndex]) {
      [nums[index], nums[elementByIndex]] = [nums[elementByIndex], nums[index]];
    } else {
      index += 1;
    }
  }

  return nums;
};
```

---
## Задачи, с применением техники

```dataviewjs
const currentFileName = dv.current().file.name;

dv.table(["Task"], dv.pages('#leetcode')
	.filter(entity => {
		const linkArray = dv.array(entity.file.outlinks.values);
		return linkArray.some(link => link.path.includes(currentFileName));
	})
	.map(entity => {
		return [entity.file.link];
	}));
```