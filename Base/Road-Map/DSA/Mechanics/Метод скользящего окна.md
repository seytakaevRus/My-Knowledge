---
tags:
  - leetcode
  - technique
---
TODO: Написать про эту технику
## Описание

`Метод скользящего окна` - метод, который позволяет эффективно решать проблемы, включающие определение окна или диапазона входных данных (массивов или строк), а затем перемещение этого окна по данным или выполнения некоторой операции внутри окна. Этот метод обычно используется в таких алгоритмах, как поиск подмассивов с определенной суммой, поиск самой длинной подстроки с уникальными символами или решение задач, требующих окна фиксированного размера для эффективной обработки элементов.

Этот метод используется в двух вариантах:
1. Фиксированное скользящее окно;
2. Скользящее окно с динамическим размером.
### Фиксированное скользящее окно

Алгоритм следующий:

- Найти размер требуемого окна, скажем `K`;
- Вычислить результат для первого окна, то есть включить первые `K` элементов структуры данных;
- Затем использовать цикл, чтобы сдвинуть окно на `1`, исключив при этом значение, которое осталось позади окна, и, включив значение, которое вошло в окно, и так продолжать вычислять результат окно за окном.

### Скользящее окно с динамическим размером

Алгоритм следующий:

- В этом типе задач мы увеличиваем правый указатель до тех пор, пока наше условие не станет истинным;
- На любом этапе, если наше условие не соответствует, то мы уменьшаем размер нашего окна, увеличивая левый указатель;
- Когда наше условие удовлетворяется, мы снова увеличиваем правый указатель;
- Выполняем эти шаги, пока не дойдем до конца массива.

### Как распознать этот паттерн

- Эти проблемы обычно требуют найти максимум/минимум `подстроки`, `подмассива`, которые удовлетворяют некоторым условиям;
- Размер `подстроки`, `подмассива` `K` будет дано в некоторых проблемах;
- Эти проблемы могут быть легко решены за `O(n^2)` используя вложенные циклы, но этот метод может улучшить этот показатель до `O(n)`.

### Чем отличается от паттерна Два указателя

`Метод скользящего окна` похож на [[Два указателя]], но главное различие заключается в том, что в `два указателя` мы сравниваем значения, которые находятся на этих указателях, вместо того, чтобы использовать все значения, находящиеся между указателями, как это делается в `методе скользящего окна`.

---
## Ограничения 

- `N <= 10^6`, если `N` — размер массива/строки.

---
## Преимущества

Проблемы, которые можно решить при помощи перебора за `O(n^2)`по времени могут быть решены при помощи `метода скользящего окна` за `O(n)` по времени.

---
## Использование

В качестве задачи возьмем [[643|Maximum Average Subarray I]].

В задаче есть `k` - длина подмассива, значит можно использовать `фиксированное скользящее окно`, нужно вычислить максимальное среднее значение в подмассиве, поэтому заводим переменную `maxSum`. В соответствии с алгоритмом, описанным выше, сначала вычисляем значение первого окна, которого располагается от `0` до `k - 1` включительно. Далее предыдущее значение удаляется из значения окна, а текущее добавляется к нему. Таким образом получается переиспользовать сумму из предыдущего окна, не вычисляя сумму заново. 

Далее сравнивается `sum` и `maxSum`, чтобы найти максимальную. А в конце вычисляем среднее значение, раз сумма была максимальная, а `k` фиксированное, то и среднее значение будет максимальным.

```typescript
const findMaxAverage = (nums: number[], k: number): number => {
  let maxSum = Number.MIN_SAFE_INTEGER;
  let sum = 0;

  for (let i = 0; i < k; i += 1) {
    sum += nums[i];
  }

  maxSum = sum;

  for (let i = k; i < nums.length; i += 1) {
    sum -= nums[i - k];
    sum += nums[i];

    maxSum = Math.max(maxSum, sum);
  }

  return maxSum / k;
};
```

---
## Задачи, с применением техники

```dataviewjs
const currentFileName = dv.current().file.name;

dv.table(["Task"], dv.pages('#leetcode')
	.filter(entity => {
		const linkArray = dv.array(entity.file.outlinks.values);
		return linkArray.some(link => link.path.includes(currentFileName));
	})
	.map(entity => {
		return [entity.file.link];
	}));
```