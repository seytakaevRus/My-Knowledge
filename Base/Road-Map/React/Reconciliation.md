`Reconciliation (согласование)` - процесс, при котором `React` обновляет реальный браузерный `DOM`. Алгоритм позволяет обновлять `DOM` быстро.

Стоит начать с того, что `React` работает с `Virtual DOM` (виртуальное дерево), а не с реальным `DOM`, потому что работа с последним медленная, а `Virtual DOM` это легковесная  копия реального `DOM` (структура из объектов), поэтому добавлять/удалять/обновлять выходит быстро.

## Как работает алгоритм согласования

Первый раз контент рисуется на странице и реальное `DOM`, а следовательно и виртуальное `DOM` деревья создаются. 

Если же происходит обновление состояния, то процесс можно поделить на три фазы:

1. `Обновление состояния` - когда состояние компонента изменяется, `React` создаёт новое виртуальное дерево и фиксирует в нём изменения;
2. `Процесс сравнение` - теперь `React` сравнивает два виртуальных дерева "до обновления состояния" и "после обновления". Цель этого алгоритма понять, какие изменения произошли;
3. `Выборочное обновление` - `React` обновляет только те части реального `DOM`, которые были изменены, а не перерисовывают всю страницу целиком.

### Обновление состояния

 В `React` каждый раз, когда мы используем хуки `useState`, `useReducer` или внешний стейт, такой как `Redux`, компонент начинает хранить часть данных, которая будет доступна на протяжении всего жизненного цикла.

TODO: 
Добавить про `батчинг`.

### Процесс сравнение

Как было сказано выше есть два дерева ("до" и "после"). Дерево "после" создаётся, когда обновляется состояние компонента.

При поочерёдном сравнении элементов из двух деревьев алгоритм придерживается следующих правил:

1. Элементы сравниваются по ссылке, если ссылка одна и та же, значит этот элемент и все элементы ниже можно не трогать (ссылку на элемент можно сделать одинаковой при помощи `useMemo` TODO: Вставить ссылку на мемоизацию);
2. Если ссылки разные, то `React` смотрим на [[Элементы и компоненты#Подробнее о `type`|type]] этих элементов:
    - Если `type` у элементов не совпадает (по ссылке или по значению), то предыдущий элемент, а также все его дочерние элементы удаляются, а новый элемент и его дочерние элементы добавляются (TODO: Вставить про анти-паттерн создание компонента внутри компонента);
    - Если `type` у элементов совпадает (по ссылке и значению), то к текущему элементу будет применены новые изменения (если они есть);
    - Для списков `React` использует пропс `key` (TODO: Оставить ссылку на него).


TODO: Перенести все примеры с type сюда