`Reconciliation (согласование)` - процесс, при котором `React` обновляет реальный браузерный `DOM`. Алгоритм позволяет обновлять `DOM` быстро.

Стоит начать с того, что `React` работает с `Virtual DOM` (виртуальное дерево), а не с реальным `DOM`, потому что работа с последним медленная, а `Virtual DOM` это легковесная  копия реального `DOM` (структура из объектов), поэтому добавлять/удалять/обновлять выходит быстро.

## Как работает алгоритм согласования

Первый раз контент рисуется на странице и реальное `DOM`, а следовательно и виртуальное `DOM` деревья создаются. 

Если же происходит обновление состояния, то процесс можно поделить на три фазы:

1. `Обновление состояния` - когда состояние компонента изменяется, `React` создаёт новое виртуальное дерево и фиксирует в нём изменения;
2. `Процесс сравнение` - теперь `React` сравнивает два виртуальных дерева "до обновления состояния" и "после обновления". Цель этого алгоритма понять, какие изменения произошли;
3. `Выборочное обновление` - `React` обновляет только те части реального `DOM`, которые были изменены, а не перерисовывают всю страницу целиком.

### Обновление состояния

 В `React` каждый раз, когда мы используем хуки `useState`, `useReducer` или внешний стейт, такой как `Redux`, компонент начинает хранить часть данных, которая будет доступна на протяжении всего жизненного цикла.

TODO: 
Добавить про `батчинг`.

### Процесс сравнение

Как было сказано выше есть два дерева ("до" и "после"). Дерево "после" создаётся, когда обновляется состояние компонента.

При поочерёдном сравнении элементов из двух деревьев алгоритм придерживается следующих правил:

1. `React` смотрим на [[Элементы и компоненты#Подробнее о `type`|type]] этих элементов:
    - Если `type` у элементов не совпадает (по ссылке или по значению), то предыдущий элемент, а также все его дочерние элементы удаляются, а новый элемент и его дочерние элементы добавляются;
    - Если `type` у элементов совпадает (по ссылке и значению), то к текущему элементу будет применены новые изменения (если они есть);
    - Для списков `React` использует пропс [[Reconciliation#`key`|key]].


Понимание алгоритма сравнения `React` позволяет решить неочевидные баги и уменьшить количество ререндеров компонентов. Ниже приведены примеры, подтверждающие алгоритм ниже.

#### Разный `type`

##### Два `React DOM` элемента

В примере ниже, если в инпут ввести текст, а затем включить и включить чекбокс, чтобы инпут появился заново, то текст пропадёт. Почему?

```js
const Form = () => {
  const [checked, setChecked] = useState(false);

  const handleChange = () => {
    setChecked(!checked);
  };

  return (
    <>
      <input type="checkbox" checked={checked} onChange={handleChange} />
      
      {checked ? (
        <input id="company-tax-id-number" placeholder="Enter you company ID" />
      ) : (
        <span>PlaceHolder</span>
      )}
    </>
  );
};
```

Благодаря [[Reconciliation#Процесс сравнение|алгоритму]] выше становится ясно, что при `checked` равным `true` должен показываться `input`, который преобразуется в:

```js
{
  type: "input",
}
```

А при `checked` равным `false` должен показываться `span`, который преобразуется в:

```js
{
  type: "span",
}
```

Поэтому при очередном вызове `useState`  идёт сравнение предыдущего `type` и следующего, а раз они разные, то предыдущий размонтируется, а следующий монтируется.

##### `React DOM` элемент и пользовательский элемент

Такая же история будет и здесь.

```js
const Input = ({ id, placeholder }) => {
  return <input id={id} placeholder={placeholder} />;
};

const Form = () => {
  const [checked, setChecked] = useState(false);

  const handleChange = () => {
    setChecked(!checked);
  };

  return (
    <>
      <input type="checkbox" checked={checked} onChange={handleChange} />

      {checked ? (
        <input id="company-tax-id-number" placeholder="Enter you company ID" />
      ) : (
        <Input
          id="person-tax-id-number"
          placeholder="Enter you personal Tax ID"
        />
      )}
    </>
  );
};
```

При `checked` равным `true`:

```js
{
  type: "input",
}
```

При `cheked` равным `false`:

```js
{
  type: Input,
}
```

`type` не совпадает, поэтому предыдущий размонтируется, следующий монтируется.

##### Анти-паттерн компонент внутри компонента

Хук `useUpdateComponentEverySecond` вызывает обновление компонента `Form` каждую секунду, каждый ререндер создаётся новый компонент `Input`, поэтому при сравнении `React` получается `{ type: Input }` и `{ type: Input }`, но ссылки на `Input` разные, поэтому один компонент он удаляет, а второй добавляет.

```js
const Form = () => {
  useUpdateComponentEverySecond();

  const Input = ({ id }) => {
    console.log("Rerender");

    useEffect(() => {
      console.log("Mount");

      return () => {
        console.log("Unmount");
      };
    }, []);

    return <input id="id" />;
  };

  return <Input id="id" />;
};
```

#### Одинаковый `type`

Будь-то два `React DOM` элемента или два пользовательских элемента, то при одинаковых `type` произойдёт  сохранение данных, хоть и один из инпутов удалится, а второй добавится (так как разные ссылки на элементы). Поэтому текст сохраняется при переключении чекбокса.

```js
const Form = () => {
  const [checked, setChecked] = useState(false);

  const handleChange = () => {
    setChecked(!checked);
  };

  return (
    <>
      <input type="checkbox" checked={checked} onChange={handleChange} />

      {checked ? (
        <input id="company-tax-id-number" placeholder="Enter you company ID" />
      ) : (
        <input
          id="person-tax-id-number"
          placeholder="Enter you personal Tax ID"
        />
      )}
    </>
  );
};
```

Кстати, если нужно, чтобы при переключении сбрасывались данные внутри элемента, то можно воспользоваться двумя способами:

2. [[Reconciliation#^c94a07|Использование условной отрисовки]];
3. [[Reconciliation#Для сброса состояния элемента|Использование пропса key]].

#### Сравнение массива с элементами, где `type` разный

В этос случае процесс не отличается от сравнение одного элемента. Если взять пример выше, то мы получим два массива.

До обновления `useState` (`checked` равный `false`):

```js
[
  {
    type: "input",
  },
  {
    type: "input",
  },
]
```

И после обновления `useState` (`checked` равный `true`):

```js
[
  {
    type: "input",
  },
  {
    type: "input",
  },
]
```

^Если переписать пример выше на два условных рендера, то поведение будет другое.  ^c94a07

```js
const Form = () => {
  const [checked, setChecked] = useState(false);

  const handleChange = () => {
    setChecked(!checked);
  };

  return (
    <>
      <input type="checkbox" checked={checked} onChange={handleChange} />

      {checked ? (
        <input id="company-tax-id-number" placeholder="Enter you company ID" />
      ) : null}
      {checked ? null : (
        <input
          id="person-tax-id-number"
          placeholder="Enter you personal Tax ID"
        />
      )}
    </>
  );
};
```

То при `checked` равный `false` получим:

```js
[
  {
    type: "input",
  },
  {
    type: "input",
  },
  null,
]
```

А при `true`:

```js
[
  {
    type: "input",
  },
  null,
  {
    type: "input",
  },
]
```

Один из инпутов удалится, а второй добавится, поэтому и сбросятся данные, связанные с элементом.

#### `key`

Пропс `key` может применяться в двух случаях:

4. Для элементов в массиве, где `type` одинаковый;
5. Для сброса состояния элемента.

##### Для элементов в массиве, где `type` одинаковый

Как было сказано выше, `React` использует `type` для понимания какой элемент удалить, добавить или обновить. Но в `React` можно создавать динамические массивы элементов с одинаковым `type`. И проблема таких динамических массивах в том, что элементы могут быть реорганизованы. Удалить, добавить элемент или просто обновить. Как тогда `React` понимает, что ему делать, ведь просто удалять все элементы и создавать их заново это затратно, для этого есть пропс `key`.

Ниже есть массив `DATA` и по нему создаётся массив из элементов `Input`. В элементе `Input` добавлены логи на монтирование, ререндер и размонтирование компонента. Также в `App` есть кнопка, которая меняет порядок элементов на обратный.

```js
const DATA = [
  { id: 1, value: 1 },
  { id: 2, value: 2 },
  { id: 3, value: 3 },
];

const Input = ({ placeholder }) => {
  console.log("Render");

  useEffect(() => {
    console.log("Mount");

    return () => {
      console.log("Unmount");
    };
  });

  return <input type="text" placeholder={placeholder} />;
};

const App = () => {
  const [data, setData] = useState(DATA);

  const toggleIsReverse = () => {
    setData([...data].reverse());
  };

  return (
    <>
      <button onClick={toggleIsReverse}>Reverse</button>
      <div
        style={{
          display: "flex",
          flexDirection: "column",
        }}
      >
        {data.map(({ id, value }) => (
          <Input placeholder={value} />
        ))}
      </div>
    </>
  );
};
```

Вот так это будет выглядеть на экране.

![[Reconciliation_1.png]]

Что будет происходить при нажатии на кнопку `Reverse` с точки зрения компонентов? [[Reconciliation#^16e023|Как мы знаем]], все элементы будут созданы заново, поэтому в консоли увидим 

##### Для сброса состояния элемента



### Выборочное обновление

^Элементы сравниваются по ссылке, если ссылка одна и та же, значит этот элемент и все элементы ниже можно не трогать (ссылку на элемент можно сделать одинаковой при помощи `useMemo` [[React_deep_dive#`memo` и компонент в `children`|посмотреть]]); ^16e023