---
tags:
  - react
refs:
  - https://www.advanced-react.com/
date: 2025-02-19
author: Ruslan Seit-Akaev
---
Хоть `замыкание` это механизм, который предоставляет `JS`, но в `React` есть ситуации, где без его глубокого понимания сложно разобраться, что происходит.

## Проблема

Предположим, что есть форма с инпутом и в ней есть очень тяжёлой компонент, который импортирован из сторонней библиотеки, поэтому к нему доступа нет и нельзя починить его проблемы с производительностью. Поэтому его оборачиваем в `React.memo`.

```js
const VerySlowComponentMemo = memo(VerySlowComponent);

const Form = () => {
  const [value, setValue] = useState();

  return (
    <>
      <input
        type="text"
        value={value}
        onChange={(e) => setValue(e.target.value)}
      />

      <VerySlowComponentMemo />
    </>
  );
};
```

Теперь мы хотим прокидывать внутрь него обработчик события по клику. В котором будет что-то делать с `value`.

```js
const VerySlowComponentMemo = memo(VerySlowComponent);

const Form = () => {
  const [value, setValue] = useState();

  const onClick = () => {
    console.log(value);
  };

  return (
    <>
      <input
        type="text"
        value={value}
        onChange={(e) => setValue(e.target.value)}
      />

      <VerySlowComponentMemo onClick={onClick} />
    </>
  );
};
```

Мы знаем, что в случае выше `memo` работать не будет, так как на каждое изменение состояние создаётся новая версия `onClick`, поэтому пропсы каждый раз будут разными. 

Первой мыслью будет обернуть `onClick` в `useCallback`, но в зависимости нужно прокидывать `value`, чтобы внутри иметь доступ к актуальному значению.

```js
const onClick = useCallback(() => {
  console.log(value);
}, [value]);
```

Только в таком случае пользы от `useCallback` будет `0`, ведь на каждое изменение `value` создаётся новая версия `onClick`.

А что если прокинуть пустой массив зависимостей?

```js
const onClick = useCallback(() => {
  console.log(value);
}, []);
```

Тогда будет выводиться всё время `undefined`, почему?

## Как работает замыкание?

^Когда создаётся функция в `JS` будь-то через слово `function` или стрелочная функция, то создаётся локальная область видимости: область, в нашем коде, где переменные объявленные внутри не будут видны снаружи. ^4d5d5c

```js
const something = () => {
  const value = 'text';
};

console.log(value);
```

Код выше выдаст ошибку, так как `value` видно только в области видимости функции `something`, но никак не за её пределами.

Функция внутри функции также создаёт область видимости и поэтому, переменные объявленные внутри не видны в теле внешней функции.

```js
const something = () => {
  const inside = () => {
    const value = "text";
  }

  console.log(value);
}

something();
```

Код выше выдаст ошибку, потому что `value` видно только внутри `inside`.

Но функция видит все переменные, которые объявлены вне её.

```js
const value = "1";

const something = () => {
  const inside = () => {
    console.log(value);
  };

  inside();

  console.log(value);
};

something();
```

Оба `console.log` выведут `1`, потому что сначала переменная будет искаться внутри текущей области видимости, если она не найдётся, пойдёт в родительскую и так до тех пор, пока не найдётся или области видимости не закончатся (глобальная является последней) и выдаст ошибку.

Также `замыкание` открывает интересный механизм.

```js
const something = (value) => {
  const inside = () => {
    console.log(value);
  };

  return inside;
};

const first = something("first");
const second = something("second");

first();
second();
```

Область видимости создаётся в [[#^4d5d5c|момент объявления функции]], поэтому каждый раз когда вызывается `something`, создаётся функция `inside` и её лексическое окружение. При вызове функции `inside` ищется внутри этого окружения `value`, не находится, поэтому ищется в окружении `something` и находится.