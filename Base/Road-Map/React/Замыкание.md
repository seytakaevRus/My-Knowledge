---
tags:
  - react
refs:
  - https://www.advanced-react.com/
date: 2025-02-19
author: Ruslan Seit-Akaev
---
Хоть `замыкание` это механизм, который предоставляет `JS`, но в `React` есть ситуации, где без понимания замыкания сложно разобраться, что происходит.

## Проблема

Предположим, что есть форма с инпутом и в ней есть очень тяжёлой компонент, который импортирован из сторонней библиотеки, поэтому к нему доступа нет и нельзя починить его проблемы с производительностью. Поэтому его оборачиваем в `React.memo`.

```js
const VerySlowComponentMemo = memo(VerySlowComponent);

const Form = () => {
  const [value, setValue] = useState();

  return (
    <>
      <input
        type="text"
        value={value}
        onChange={(e) => setValue(e.target.value)}
      />

      <VerySlowComponentMemo />
    </>
  );
};
```

Теперь мы хотим прокидывать внутрь него обработчик события по клику. В котором будет что-то делать с `value`.

```js
const VerySlowComponentMemo = memo(VerySlowComponent);

const Form = () => {
  const [value, setValue] = useState();

  const onClick = () => {
    console.log(value);
  };

  return (
    <>
      <input
        type="text"
        value={value}
        onChange={(e) => setValue(e.target.value)}
      />

      <VerySlowComponentMemo onClick={onClick} />
    </>
  );
};
```

Мы знаем, что в случае выше `memo` работать не будет, так как на каждое изменение состояние создаётся новая версия `onClick`, поэтому пропсы каждый раз будут разными. 

Первой мыслью будет обернуть `onClick` в `useCallback`, но в зависимости нужно прокидывать `value`, чтобы внутри иметь доступ к актуальному значению.

```js
const onClick = useCallback(() => {
  console.log(value);
}, [value]);
```

Только в таком случае пользы от `useCallback` будет `0`, ведь на каждое изменение `value` создаётся новая версия `onClick`.

А что если прокинуть пустой массив зависимостей?

```js
const onClick = useCallback(() => {
  console.log(value);
}, []);
```

Тогда будет выводиться всё время `undefined`, почему?

## Как работает замыкание?

Прежде чем перейти к разбору, важно уточнить два термина, которые встречаются чаще всего, когда идёт речь об `замыкании`:

1. `Область видимости`;
2. `Лексическое окружение`.

### Область видимости

`Область видимости` - это абстрактное понятие, которое говорит, какие переменные доступны в определённой части кода. `Область видимости` является статической, это означает, что область определяется на этапе объявления функции, а не в моменте её вызова.

Это значит, что функция запоминает переменные во время своего объявления. Что это нам даёт?

Рассмотрим работу разных областей видимости. Начнём со статической, как это работает в `JS` сейчас.

```js
const a = "global";

const outer = () => {
  const a = "outer";

  const inner = () => {
    console.log(a);
  }

  inner();
}

outer();
```

Здесь выведется `outer`, потому что во время объявления функции `inner`, она запомнила переменную `a` в родительском окружении (в функции `outer`). И в момент вызова функции `inner` она обращается к запомненной ранее переменной `a`.

Если бы области видимости была бы динамической, то вызов функции `outer` на строчке `1` вывел `outer`, а вызов функции `inner` на строчке `2` вывел бы `inner`. Потому что поиск переменной производился бы по стэку вызов функций, а не окружениям. 

```js
const a = "global";

const inner = () => {
  console.log(a);
}

const outer = () => {
  const a = "outer";
  inner();
}

outer(); // 1
inner(); // 2
```

Но в реальном мире (где область видимости статическая и создаётся на этапе объявления функции) выведется `global` и `global`, так как при объявлении функции `inner` она запоминает переменную `a`, которая находится в глобальном окружении.

### Лексическое окружение

`Лексическое окружение` - 

^Когда создаётся функция в `JS` будь-то через слово `function` или стрелочная функция, то создаётся область видимости: область, в нашем коде, где переменные объявленные внутри не будут видны снаружи. ^4d5d5c

```js
const something = () => {
  const value = 'text';
};

console.log(value);
```

Код выше выдаст ошибку, так как `value` видно только в области видимости функции `something`, но никак не за её пределами.

Функция внутри функции также создаёт область видимости и поэтому, переменные объявленные внутри не видны в теле внешней функции.

```js
const something = () => {
  const inside = () => {
    const value = "text";
  }

  console.log(value);
}

something();
```

Код выше выдаст ошибку, потому что `value` видно только внутри `inside`.

Но функция видит все переменные, которые объявлены вне её.

```js
const value = "1";

const something = () => {
  const inside = () => {
    console.log(value);
  };

  inside();

  console.log(value);
};

something();
```

Оба `console.log` выведут `1`, потому что сначала переменная будет искаться внутри текущей области видимости, если она не найдётся, пойдёт в родительскую и так до тех пор, пока не найдётся или области видимости не закончатся (глобальная является последней) и выдаст ошибку.

Также `замыкание` открывает интересный механизм.

```js
const something = (value) => {
  const inside = () => {
    console.log(value);
  };

  return inside;
};

const first = something("first");
const second = something("second");

first();
second();
```

Область видимости создаётся в [[#^4d5d5c|момент объявления функции]], поэтому каждый раз когда вызывается `something`, создаётся функция `inside` и её лексическое окружение. При вызове функции `inside` ищется внутри этого окружения `value`, не находится, поэтому ищется в окружении `something` и находится.