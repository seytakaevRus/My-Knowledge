---
tags:
  - react
refs:
  - https://www.advanced-react.com/
date: 2025-02-19
author: Ruslan Seit-Akaev
---
Хоть `замыкание` это механизм, который предоставляет `JS`, но в `React` есть ситуации, где без понимания замыкания сложно разобраться, что происходит.

## Кейс

Предположим, что есть форма с инпутом и в ней есть очень тяжёлой компонент, который импортирован из сторонней библиотеки, поэтому к нему доступа нет и нельзя починить его проблемы с производительностью. Поэтому его оборачиваем в `React.memo`.

```jsx
const VerySlowComponentMemo = memo(VerySlowComponent);

const Form = () => {
  const [value, setValue] = useState();

  return (
    <>
      <input
        type="text"
        value={value}
        onChange={(e) => setValue(e.target.value)}
      />

      <VerySlowComponentMemo />
    </>
  );
};
```

Теперь мы хотим прокидывать внутрь него обработчик события по клику. В котором будет что-то делать с `value`.

```jsx
const VerySlowComponentMemo = memo(VerySlowComponent);

const Form = () => {
  const [value, setValue] = useState();

  const onClick = () => {
    console.log(value);
  };

  return (
    <>
      <input
        type="text"
        value={value}
        onChange={(e) => setValue(e.target.value)}
      />

      <VerySlowComponentMemo onClick={onClick} />
    </>
  );
};
```

Мы знаем, что в случае выше `memo` работать не будет, так как на каждое изменение состояние создаётся новая версия `onClick`, поэтому пропсы каждый раз будут разными. 

Первой мыслью будет обернуть `onClick` в `useCallback`, но в зависимости нужно прокидывать `value`, чтобы внутри иметь доступ к актуальному значению.

```js
const onClick = useCallback(() => {
  console.log(value);
}, [value]);
```

Только в таком случае пользы от `useCallback` будет `0`, ведь на каждое изменение `value` создаётся новая версия `onClick`.

А что если прокинуть пустой массив зависимостей?

```js
const onClick = useCallback(() => {
  console.log(value);
}, []);
```

Тогда будет выводиться всё время `undefined`, почему?

## Как работает замыкание?

Прежде чем перейти к разбору, важно уточнить два термина, которые встречаются чаще всего, когда идёт речь об `замыкании` - `область видимости` и `лексическое окружение`.

### Область видимости и лексическое окружение

`Область видимости (ОВ)` - это абстрактное понятие, которое говорит, какие переменные доступны в определённой части кода. `ОВ` является статической, это означает, что область определяется на этапе объявления функции, а не в моменте её вызова.

`Лексическое окружение (ЛО)` - конкретная структура, которая хранит текущие значения переменных и ссылку на `ЛО` родителя. Окружение создаётся в момент вызова функции. Если взять аналогия, то `ОВ` это `стек`, а `ЛО` это реализация `стека` через `массив` или через `cвязанный список`.

По сути процесс делится на два этапа:

1. Компиляция. `JS` анализирует код и определяет какие переменные и функции доступны в каждой `ОВ`, также он определяет в каком `ЛО` стоит искать переменную или функцию, если она не была найдена в текущем (само `ЛО` ещё не создано, так как функция ещё не вызвана);
2. Выполнение. При вызове функции создаётся новое `ЛО`. В это окружение записываются текущие переменные и ссылка на родительское `ЛО`.

Понятие `статическая` или `динамическая` `область видимости` определяет процесс, по которому будет определяться родительское `лексическое окружение`.

В случае со статической `ОВ`. Определение идёт в момент объявления функции. То есть при объявлении функции `inner` определяется, что поиск переменной `a` будет проводиться в `ЛО` `outer`, если в текущем `ЛО` переменная не была найдена.

```js
const a = "global";

const outer = () => {
  const a = "outer";

  const inner = () => {
    console.log(a);
  }

  inner();
}

outer();
```

Поэтому здесь выведется `outer`.

В случае же с динамической `ОВ`. Определение кто будет родителем происходит в момент вызова функции через стек вызовов. При вызове `outer` создаётся её `ЛО`, далее вызывается `inner` и поиск идёт в `ЛО` `outer`. А в случае вызова `inner` не внутри `outer`, поиск будет происходить в глобальном `ЛО`. 

```js
const a = "global";

const inner = () => {
  console.log(a);
}

const outer = () => {
  const a = "outer";
  inner();
}

outer(); // 1
inner(); // 2
```

Поэтому будет `outer` и `global`

Но в реальном мире (где `ОВ` статическая и создаётся на этапе объявления функции) выведется `global` и `global`, так как при объявлении функции `inner` она запоминает переменную `a`, которая находится в глобальном окружении.

### О замыкании

`Замыкание` - это как раз способность функции к запоминанию родительского `ЛО` и всех её переменных/функций. Как было сказано выше, если в функции идёт доступ к переменной, которой нет в текущем `ЛО`, `JS` ищет её в родительском. Это открывает нам интересные механики.

```js
const something = (value) => {
  const inside = () => {
    console.log(value);
  };

  return inside;
};

const first = something("first");
const second = something("second");

first();
second();
```

При вызове функции `something` (и созданию функции `inside`) функция `inside` запоминает родительское `ЛО` и её переменную `value`. Поэтому при вызове `something` с разными значениями, и последующем вызове возвращённых функций, будут выведены переданные в `something` значения.

> ^Замыкание существует до тех пор, ссылка на функцию, которая вызвала это самое замыкание, доступна. Если на `ЛО`, благодаря которому и возможна работа замыкания, ничего не указывает, то [[Управление памятью#Сборка мусора|сборщик мусора]] просто удалит это `ЛО`, а вместе с ним пропадёт и замыкание.

## Возвращаясь в `React`

### `useCallback`

[[React_deep_dive#Мемоизация|Как мы знаем]] `useCallback` используется, чтобы запоминать ссылку на функцию при одинаковых зависимостях. При создании функции внутри `useCallback`, функция запоминает родительское `ЛО`, в котором переменная `value` равна `undefined`.

```jsx
const VerySlowComponentMemo = memo(VerySlowComponent);

const Form = () => {
  const [value, setValue] = useState();

  const onClick = useCallback(() => {
    console.log(value);
  }, []);

  return (
    <>
      <input
        type="text"
        value={value}
        onChange={(e) => setValue(e.target.value)}
      />

      <VerySlowComponentMemo onClick={onClick} />
    </>
  );
};
```

 А если в зависимость прокинуть `value`, то каждое изменение создаёт новую версию функции, а значит функция запоминает актуальное `value`.

### `useRef`

Что будет, если в примере выше мы `onClick` обернём в `useRef`. Нет зависимостей, нет проблем, верно?

Ну, не совсем. [[Refs#Отличие `useRef` от `useState` на примере|Так как]] `useRef` хранит значение или ссылку, пока оно не будет изменено, то функция внутри запомнит `value` как `undefined`. Поэтому `useRef` таким образом также не решит проблему. 

```jsx
const VerySlowComponentMemo = memo(VerySlowComponent);

const Form = () => {
  const [value, setValue] = useState();

  const onClick = useRef(() => {
    console.log(value);
  });

  return (
    <>
      <input
        type="text"
        value={value}
        onChange={(e) => setValue(e.target.value)}
      />

      <VerySlowComponentMemo onClick={onClick.current} />
    </>
  );
};
```

Единственное, что можно сделать, это обновлять `ref` внутри `useEffect` во время изменения `value`.

```js
const onClick = useRef(() => {
  console.log(value);
});

useEffect(() => {
  onClick.current = () => {
    console.log(value);
  };
}, [value]);
```

Примерно это делается при изменении массива зависимостей, поэтому, по сути, мы пересоздали `useCallback`.

## Сочетание `useCallback` и `useRef` для решения кейса

Итак, чтобы мемоизация работала, нужно в `VerySlowComponentMemo` прокидывать одну и ту же ссылку, но чтобы функция имела доступ к последнему значению `value` она должна пересоздавать каждый раз, так что делать?)

Ответ: совместить `useCallback` и `useRef`. Внутри `useCallback` вызывать функцию, которая лежит в `useRef`, а чтобы функция имела доступ к последнему значению `value` внутри `useEffect` пересоздавать её.

```jsx
const VerySlowComponentMemo = memo(VerySlowComponent);

const Form = () => {
  const [value, setValue] = useState();

  const ref = useRef(() => {
    console.log(value);
  });

  useEffect(() => {
    ref.current = () => {
      console.log(value);
    };
  });

  const onClick = useCallback(() => {
    ref.current();
  }, []);

  return (
    <>
      <input
        type="text"
        value={value}
        onChange={(e) => setValue(e.target.value)}
      />

      <VerySlowComponentMemo onClick={onClick} />
    </>
  );
};
```

