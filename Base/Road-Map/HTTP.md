## Что такое HTTP

`HTTP` - это `TCP/IP` протокол, который находится на уровне приложений в модели `OSI`. Протокол стандартизирует как клиенты и серверы взаимодействуют между собой, также определяет как контент запрашивается и передается по Интернету. По умолчанию используется порт `80`, хотя остальные порты также могут быть использованы, `HTTPS` использует порт `443`.

Является протоколом без сохранения состояния. То есть каждая команда выполняется независимо от любой другой команды.

### HTTP запрос

`Запрос` - это способ взаимодействия, происходящий от клиента к серверу. 

Типичный `HTTP запрос` состоит из:
1. Метода;
2. URL;
3. Заголовков запроса;
4. Тело запроса, может быть, а может отсутствовать.

### HTTP ответ

`Ответ` - это способ взаимодействия, происходящий от сервера к клиенту. 

Обычно состоит из:
1. Статуса кода;
2. Заголовков ответа;
3. Тело ответа, может быть, а может отсутствовать.

### HTTP метод

`HTTP метод` - отображает действие, которое клиент ожидает от сервера, к примеру, `GET` означает получить что-то от сервера, `POST` означает что-то создать, поэтому можно передать тело в запрос.

### HTTP заголовки

`HTTP заголовки` - текстовая информация, которая хранится в паре `ключ:значение` и присутствует в каждом `HTTP запросе`, также бывает и в `HTTP ответе`. Заголовки содержат такую информацию как, какой браузер использует клиент или тип запрашиваемых данных.

Пример заголовков HTTP запроса

![[Pasted image 20240213225841.png]]

Пример заголовков HTTP ответа

![[Pasted image 20240213230445.png]]

### Тело HTTP запроса/ответа

`Тело` - это дополнительная информация, которую клиент передает на сервер, к примеру, логин и пароль или другие данные, которые были введены в форму.

### HTTP статусы кодов

`Статус кода` - несет в себе общую информацию, что произошло и где может быть ошибка. Делится на следующие группы:

1. `1xx` Информационные;
2. `2xx` Успех;
3. `3xx` Перенаправление;
4. `4xx` Ошибка на стороне клиента;
5. `5xx` Ошибка на стороне сервера.

`xx` это любое число от `00` до `99`. К примеру, статус `200` показывает, что запрос прошел успешно. А статус `404`, что такая страница не была найдена, потому что клиент ввел неправильный `URL`.
## История HTTP

### HTTP/0.9

Эта версия HTTP появилась в 1991 году. Это был очень простой протокол, который имел только метод `GET`.

Как только сервер получал запрос, он отвечал на него страницей `HTML` и закрывал соединения.

В итоге:
- Нет заголовков;
- `GET` единственный разрешенный метод;
- Ответом был `HTML`.

### HTTP/1.0

Эта версия появилась в 1996 году. Эта версия принесла много нового, ответом мог быть не только `HTML`, но и видео, картинки или просто текст, были добавлены методы `POST`, `HEAD`, заголовки, кэширование и многое другое.

Одним из главных недостатков `HTTP/1.0` было отсутствие нескольких запросов на одно соединение. То есть когда клиенту понадобится что-то от сервера ему нужно открыть `TCP` соединение и после получения данных закрыть его. И для любого следующего запроса будет происходить такая же схема. А открытие и закрытие соединения затрачивает ресурсы сервера.

### Трехстороннее рукопожатие

`Трехстороннее рукопожатие` - это процесс, который используется в `TCP/IP` для установления соединения между сервером и клиентом. Это происходит перед обменом данных.

- SYN - клиент выбирает рандомное число, скажем, `x` отправляет его серверу;
- SYN ACK - сервер подтверждает запрос тем, что отправляет клиенту пакет, где содержится рандомное число, которое выбрал сервер, скажем, `y` и число `x + 1`, где `x` это то, что выбрал клиент;
- ACK -  клиент отправляет число `y + 1` на сервер.

С помощью такого механизма происходит подтверждение того, что между сервером и клиентом можно передавать данные. Далее происходит обмен данных.

![[Pasted image 20240213144327.png]]

### HTTP/1.1

Эта версия появилась в 1999  году. Что было сделано:
- Добавлены новый методы `PUT`, `PATCH`, `OPTIONS`, `DELETE`;
- Добавлена возможность поддерживать соединение открытым, в прошлой версии после получения данных соединение закрывалось, поэтому на `1` запрос шло `1` соединение, в этой версии в `1` соединении можно сделать несколько запросов;
- Добавлена возможность конвейра. Это значит, что теперь второй запрос может быть отправлен раньше, чем придет ответ от первого запроса. Благодаря этому уменьшается задержка между запросами. Важно отметить, что при использовании конвейера сервер должен отсылать ответы в том же порядке, что и запросы.
- Добавлена возможность делить ответ на чанки, это сделано для динамических данных;
- Поддержка кук на клиенте;
- И многое другое.

### SPDY

Этот протокол разрабатывал Гугл и анонсировал в 2009 году. `SPDY` приносил кучу всего нового, мультиплексирование, сжатие, приоритизацию и многое другое.

Это не было заменой `HTTP`. Это был бы протокол, который работает поверх `HTTP`.

В 2015 в Гугле подумали, что им не нужно 2 стандарта `HTTP` и `SPDY` и решили влить его в `HTTP`, дав рождение `HTTP/2` и перестав поддерживать `SPDY`.

### HTTP/2

#### Бинарный протокол

Чтобы уменьшить задержку в `HTTP/2` решили сделать протокол бинарным. Его будет легче парсить, но в отличие от `HTTP/1.x` его данные не будут доступны человеческому глазу, так как данные будут представлять комбинацию `0` и `1`. Главные строительные блоки в этой `HTTP/2` `фреймы` и `стримы`.

Теперь `HTTP` сообщения состоят из нескольких `фреймов`. `Фрейм` - бинарный кусок данных, а коллекция таких кусков называется `стрим`. Теперь каждый `HTTP/2` запрос и ответ содержит уникальный `ID` стрима, и каждый фрейм содержит `ID` стрима, чтобы было понятно к какому стриму принадлежит фрейм.

#### Мультиплексирование

После открытия `TCP-соединения` все потоки отправляются асинхронно через одно и тоже соединение без открытия дополнительных. Сервер также отвечает асинхронно, ответ теперь не имеет порядка и клиент использует `ID` потока для идентификации стрима и фрейма. Можно сказать, что это следующая ступень после конвейера, который был добавлен в `HTTP/1.1`.

На рисунке ниже показано отличие конвейра от мультиплексирования.

Без конвейеризации (левая часть рисунка) браузер должен дождать полного ответа на первый запрос и только после этого он сможет отправить второй запрос.

С конвейеризации (середина рисунка) браузеру не нужно ждать ответы от сервера, он может отправлять запросы подряд. Но ответы должны поступить в том же порядке, в котором были запросы.

Настоящее мультиплексирование изображено на правой части рисунка, браузер и отправляет асинхронно и получает асинхронно.


![[Pasted image 20240214161632.png]]

#### Сжатие заголовков

Чтобы уменьшить задержку было предложено начать сжимать заголовки, но в отличии от запроса и ответа сжимать их с помощью `gzip` или `compress` не выйдет. Здесь происходит сжатие при помощи алгоритма Хаффмана.

#### Сервер отсылает данные, которые клиент еще не запрашивал

Сервер знает, что некоторые ресурсы клиент у него попросит после того, как клиент загрузит всю веб-страницу и посмотрит, что вообще нужно. Поэтому сервер посылает данные, которые пригодятся клиенту, это позволяет уменьшить количество обращений клиента к серверу, так как после получения данных клиент их уже не попросит у сервера.

#### Приоритизация запросов

Клиент может указать приоритет какому-то потоку. Без приоритетов сервер обрабатывает все запросы асинхронно. Если потоку назначен приоритет, то на основе этой информации о приоритетах сервер решает, сколько ресурсов необходимо выделить для обработки того или иного запроса.

### HTTP/3

Новая версия протокола была создана для использования `HTTP` поверх протокола `QUIC`, который включает в себя большинство новых функций. 

![[Pasted image 20240214155600.png]]

В `HTTP3`:
1. Не используется `TCP`;
2. Мультиплексирования с уровня приложений (`HTTP`) перебирается на уровень транспорта (`QUIC` + `UDP`).

#### Исправление с HOL

`HOL (Head-of-Line blocking)` - явление в компьютерных сетях, когда один пакет в очереди потерялся, поэтому остальные пакеты после него должны будут ждать, пока этот пакет придет вновь.

В `HTTP/2` `HOL` был на уровне `TCP`, для `TCP` данные это один большой поток, поделенный на пакеты, если одного из пакетов нет (потерялся, например), то остальные пакеты не смогут быть переданы браузеру (`TCP` гарантирует доставку пакетов в определенном порядке).

В `QUIC` же используется мультиплексирование, но на транспортном уровне, здесь также используются `фреймы` и `стримы`, а значит можно запускать несколько `стримов` и тем самым, если пакет из `стрима` `1` потерялся, то это не задерживает пакеты из стрима `2` и `3`.

![[Pasted image 20240214230425.png]]

#### Уменьшение количества рукопожатий

В отличии от `TCP` + `TLS` `QUIC` использует меньше рукопожатий для перед началом передачи данных. Раньше было отдельное трехстороннее рукопожатие для `TCP`, отдельные рукопожатие для `TLS`, а сейчас `QUIC` можешь шифровать данные почти на первом рукопожатии.

![[Pasted image 20240214231856.png]]

#### Другой алгоритм сжатия заголовков

Вместо `HPACK` теперь используется `QPACK` из-за новых механизмов, которые принес `QUICK`.

#### Миграция IP-адреса

Ещё одной интересной особенностью использования протокола UDP является то, что вы больше не привязаны к IP сервера. В протоколе TCP соединение определяется четырьмя параметрам: IP-адресами сервера и клиента, портами сервера и клиента. В Linux вы можете увидеть эти параметры для каждого установленного соединения с помощью команды netstat:

![[Pasted image 20240214233506.png]]

Если любой из этих четырёх параметров потребуется изменить — нам потребуется открывать новое TCP-соединение. Вот почему трудно поддерживать стабильную связь на мобильных устройствах при переключении между WiFi и 3G/LTE.

В QUIC, с его использованием UDP, данного набора параметров больше нет. QUIC вводит понятие идентификатора соединения, называемого Connection UUID. Появляется возможность перейти с WiFi на LTE с сохранением Connection UUID, таким образом избежав затрат на пересоздание соединения. Похожим образом работает [Mosh Shell](https://mosh.mit.edu/), сохраняя SSH-соединение активным при смене IP-адреса.