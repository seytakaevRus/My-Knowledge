---
tags:
  - roadmap
refs:
  - https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy
  - https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS
date: 
author: Ruslan Seit-Akaev
---
## Что такое CORS

`CORS (Cross-Origin Resource Sharing)` - механизм, который базируется на заголовках. Позволяет серверу указывать любые [[CORS#Политика одного и того же источника|источники]] (домен, схему или порт), отличные от его собственных, откуда браузер будет разрешать загрузку ресурсов. Предварительный ответ можно дополнительно кэшировать для запросов, созданных по тому же URL-адресу, с использованием заголовка Access-Control-Max-Age, как в приведенном выше примере. Для кэширования предварительных ответов браузер использует специальный кеш, отдельный от общего кэша HTTP, которым управляет браузер. Предварительные ответы никогда не кэшируются в общем HTTP-кеше браузера.

По причинам безопасности браузеры ограничивают кросс-доменные HTTP запросы, которые инициирует скрипт. К примеру `fetch()` и `XMLHttpRequest` следуют [[CORS#Политика одного и того же источника|политике одного и того же источника]]. Это означает, что веб-приложение, использующее эти API, может запрашивать ресурсы только из того же источника, из которого было загружено приложение, если только ответ из других источников не содержит правильные заголовки CORS.

![[CORS_1.png]]

Механизм CORS работает только между браузерами и серверами. Если приложение будет посылает запросы к серверу, не используя браузер, то механизм CORS применяться не будет.

Благодаря механизму`CORS` браузер может блокировать, как запросы от клиента, так и ответы от сервера.
## Какие запросы используют CORS

1. Вызов `fetch` или `XMLHttpRequest`, как было описано выше;
2. Загрузка шрифтов;
3. Загрузка картинок или видео.

## Примеры сценариев доступа

### Простой запрос

Некоторые запросы не вызывают предварительного запроса CORS. Такие запросы называют `простыми`. Они подпадают под условия, которые описаны ниже:
1. Методов запроса является:
	- GET;
	- HEAD;
	- POST.
2. Помимо заголовков, которые браузер добавляется автоматически (Connection, User-Agent и другие), в запросе могут присутствовать заголовки, которые внесены в `список безопасных заголовков CORS`:
	- Accept;
	- Accept-Language;
	- Content-Language;
	- Content-Type (`application/x-www-form-urlencoded`,  `multipart/form-data` или `text/plain`);
3. Никакого `ReadableStream` объекта не используется в запросе.

Представим, что клиентская часть находится на `https://foo.example`, а серверная на `https://bar.other`.

Код ниже будет выполнять простой запрос.

```js
const fetchPromise = fetch("https://bar.other");

fetchPromise
  .then((response) => response.json())
  .then((data) => {
    console.log(data);
   });
```

Вот как это будет выглядеть:

![[CORS_2.png]]

В этом случае браузер пошлет запрос, в котором будет заголовок `Origin`, который показывает, что вызов шел с `https://foo.example`. И заголовок `Host`, который показывает куда идет запрос.

```http
GET /resources/public-data/ HTTP/1.1
Host: bar.other
Origin: https://foo.example
```

В ответе сервера будет заголовок `Access-Control-Allow-Origin`, значение `*` говорит о том, что ресурс может быть доступен любому источнику. Хорошей практикой является указанием здесь конкретного источника, а не символа `*`, в данном случае можно указать `https://foo.example`.

```http
HTTP/1.1 200 OK
Access-Control-Allow-Origin: *
```
### Предварительный запрос

В отличие от [[CORS#Простой запрос|простого запроса]] браузер сперва отправляет HTTP запрос, использующий метод `OPTIONS`, чтобы определить безопасно ли отправлять фактический запрос. Такие запросы выполняются предварительно, так как они могут иметь последствия для пользовательских данных.

Код ниже будет выполнять запрос с предварительным запросом: 

```js
const fetchPromise = fetch("https://bar.other/doc", {
  method: "POST",
  mode: "cors",
  headers: {
    "Content-Type": "text/xml",
    "X-PINGOTHER": "pingpong",
  },
  body: "<person><name>Arun</name></person>",
});
```

Это запрос создает `XML` тело и отправляет его в `POST` запросе. Также используется заголовок не со `списка безопасных заголовков CORS` и у заголовка `Content-Type` значение отличается от тех, которые используется в простых запросах. Поэтому этот запрос будет с предварительным запросом.

![[CORS_3.png]]

Сначала браузер отправляет запрос с методом `OPTIONS` и в нем представлены `Access-Control-Request-Method`, этот заголовок сообщает, что при исполнении реального запроса будет использоваться метод `POST`. А заголовок `Access-Control-Request-Headers` сообщает, что при исполнении реального запроса будут использованы заголовки `X-PINGOTHER` и `Content-Type`. 

```http
OPTIONS /doc HTTP/1.1
Host: bar.other
Origin: https://foo.example
Access-Control-Request-Method: POST
Access-Control-Request-Headers: X-PINGOTHER, Content-Type
```

В ответе сервера в заголовке `Access-Control-Allow-Methods` указываются методы, которые сервер разрешает использовать при реальном запросе. В заголовке `Access-Control-Allow-Headers` указываются заголовки, которые сервер разрешает использовать при реальном запросе.

Предварительный ответ можно дополнительно кэшировать для запросов, созданных по тому же URL-адресу, с использованием заголовка `Access-Control-Max-Age`, как в приведенном выше примере. Для кэширования предварительных ответов браузер использует специальный кеш, отдельный от общего кэша HTTP, которым управляет браузер. Предварительные ответы никогда не кэшируются в общем HTTP-кеше браузера.

```http
HTTP/1.1 204 No Content
Access-Control-Allow-Origin: https://foo.example
Access-Control-Allow-Methods: POST, GET, OPTIONS
Access-Control-Allow-Headers: X-PINGOTHER, Content-Type
Access-Control-Max-Age: 86400
```

После получения ответа по предполетному запроса, отправляется реальный запрос.

```http
POST /doc HTTP/1.1
Host: bar.other
X-PINGOTHER: pingpong
Content-Type: text/xml; charset=UTF-8
Content-Length: 55
Origin: https://foo.example

<person><name>Arun</name></person>
```

```http
HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:15:40 GMT
Access-Control-Allow-Origin: https://foo.example
Content-Encoding: gzip
Content-Length: 235
Content-Type: text/plain

[Some XML payload]
```
### Простой запрос с кредами

В это примере клиент на `https://foo.example` делает простой `GET` запрос на ресурс `https://bar.other`, который будет добавлять куки в ответ.

Клиент делает такой запрос:

```js
const url = "https://bar.other/resources/credentialed-content/";

const response = fetch(url, {
    credentials: 'include'
});
```

`credentials: include` означает, что с получением кук браузер будет их включать в каждый запрос к серверу. Если эта настройка была добавлена, то сервер должен отсылать `Access-Control-Allow-Credentials` со значением `true`, означающий, что включение кредов разрешено, если его не включить на сервере, то браузер не примет ответ.

![[CORS_4.png]]

Клиент сделает запрос со следующими заголовками.

```http
GET /resources/credentialed-content/ HTTP/1.1
Host: bar.other
Origin: https://foo.example
```

А сервер ответит так, где будет заголовок `Access-Control-Allow-Credentials` и также `Set-Cookie`, где указано значение куки.

```http
HTTP/1.1 200 OK
Access-Control-Allow-Origin: https://foo.example
Access-Control-Allow-Credentials: true
Set-Cookie: pageAccess=3; expires=Wed, 31-Dec-2008 01:34:53 GMT
Content-Type: text/plain

[text/plain payload]
```
### Запрос с предварительным запросом и кредами

Предварительные запросы никогда не должны включать в себя креды. Ответ на предварительный запрос должен указывать `Access-Control-Allow-Credentials: true`, чтобы обозначить, что реальный запрос может быть сделан со включением кредов.

### При использование запросов с кредами

Не нужно использовать `*` в заголовках `Access-Control-Allow-Origin`, `Access-Control-Allow-Headers`, `Access-Control-Allow-Methods`. Это не безопасно и из-за таких заголовках, если в них были включены креды, браузер будет блокировать ответ.
## Политика одного и того же источника

`Политика одного и того же источника` - механизм по безопасности, который ограничивается возможность документа или скрипта, скаченного с одного источника взаимодействовать с ресурсом с другого источника.

Совокупность схемы (протокола), имя хоста (домена) и порта все это является частью URL-адреса и является `источником`.

### Определение похожести источников

Источники будут похожими, если у них совпадают протокол, порт (если указан) и имя хоста (домен).

Внизу приведены примеры похожести или различия источников с источником `http://store.company.com/dir/page.html`.

![[CORS_5.png]]