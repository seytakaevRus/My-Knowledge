---
tags:
  - roadmap
refs:
  - https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work
date: 2024-03-01
author: Ruslan Seit-Akaev
---
Две главных проблемы в веб-производительности связаны с задержкой  и с тем фактом, что по большей части браузеры являются однопоточными.
## Навигация 

`Навигация` - первый шаг в загрузке веб-страницы. Она происходит тогда, когда пользователь запрашивает страницу через ввод URL в адресную строку, кликает на ссылку, подтверждает форму и т.д.

Для повышение веб-производительности, можно уменьшить время навигации, но `задержка` и `пропускная способность` - враги, которые могут помешать.

Про передачу информации по сети можно прочитать [[Как работает Интернет#Передача информации по сети|здесь]]
### DNS поиск

Как происходит DNS поиск можно прочитать  [[DNS#DNS запрос (без подробностей)|здесь]].

На веб-странице может присутствовать множество ресурсов такие как: картинки, стили, шрифты или медиа. И для каждого ресурса, если будет разный хост, будет проведен DNS-поиск.

### TCP рукопожатие

Как IP-адрес нужного веб-сервера становится известным, происходит [[HTTP#Трехстороннее TCP рукопожатие|TCP рукопожатие]].

### TLS согласование

Для защищенных соединений после `TCP рукопожатия` требуется еще одно "рукопожатие". Оно определяет, какой шифр будет использоваться для шифрования связи, проверяет сервер и устанавливает наличие безопасного соединения перед началом фактической передачи данных.

## Ответ

После того как было установлено соединение с веб-сервером браузер отсылает начальный HTTP GET запрос от имени пользователя. Как сервер получает запрос он отсылает HTML файл.

```html
<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8" />
    <title>My simple page</title>
    <link rel="stylesheet" href="styles.css" />
    <script src="myscript.js"></script>
  </head>
  <body>
    <h1 class="heading">My Page</h1>
    <p>A paragraph with a <a href="https://example.com/about">link</a></p>
    <div>
      <img src="myimage.jpg" alt="image description" />
    </div>
    <script src="anotherscript.js"></script>
  </body>
</html>
```

Этот ответ на начальный запрос содержит первые байты полученных данных. `TTFB (Time to First Byte)` - время между, когда пользователь сделал запрос и когда пользователь получил первый пакет байт, в данном случае это HTML.

## Парсинг

Как только браузер получил первый чанк (часть данных) он может начать парсить полученную информацию. `Парсинг` - это шаг, когда браузер превращает всю полученную информацию в `DOM` и `CSSOM`, который используются для отрисовки страницы на экран.

`DOM` — это внутреннее представление разметки браузера. DOM также доступен и им можно манипулировать с помощью различных API в JavaScript.

### Строительство DOM дерева

TODO: Написать про критический путь (https://developer.mozilla.org/en-US/docs/Web/Performance/Critical_rendering_path).

Первым шагом является обработка HTML разметки и построение DOM дерева. Парсер браузера распознает HTML теги и на их основе строит DOM дерево.

DOM дерево описывает контент документа. Дерево DOM описывает содержимое документа. Элемент `<html>` — это первый элемент и корневой узел дерева документа. Дерево отражает отношения и иерархию между различными элементами. Элементы, вложенные в другие элементы, являются дочерними узлами. Чем больше узлов DOM, тем больше времени требуется для построения дерева DOM.

![[Как_работают_браузеры_1.png]]

Когда парсер находит неблокирующие ресурсы, такие как картинки, браузер делает запрос на эти ресурсы и продолжает парсинг.  Парсинг может продолжаться при обнаружении файла CSS, но элементы `<script>` особенно те, у которых нет атрибута `async` или `defer` блокируют рендеринг и приостанавливают анализ HTML. Хотя `сканер предварительной загрузки` браузера ускоряет этот процесс, чрезмерное количество скриптов все равно может стать серьезным узким местом.

### Сканер предварительной загрузки

Пока браузер строит дерево DOM, этот процесс занимает основной поток. Пока это происходит `сканер` анализирует контент дальше и делает запрос на высоко-приоритетные ресурсы, которые нашел, такие как CSS, JavaScript и шрифты. Благодаря этому, не нужно ждать пока парсер найдет ссылку на внешний ресурс и запросит его. Получение таких ресурсов происходит асинхронно, поэтому когда HTML парсер доберется до запрашиваемых ресурсов в HTML, их уже могли запросить или они могут быть загружены. Оптимизацию, которую предоставляет сканер уменьшает блокировку основного парсера. 

```html
<link rel="stylesheet" href="styles.css" />
<script src="myscript.js" async></script>
<img src="myimage.jpg" alt="image description" />
<script src="anotherscript.js" async></script>
```

В этом примере, пока основной поток анализирует HTML и CSS, сканер предварительной загрузки найдет скрипты и изображения и также начнет их загрузку. Чтобы скрипт не блокировал процесс, добавь атрибут `async` или атрибут `defer`, если порядок анализа и выполнения JavaScript важен.

Ожидание получения CSS не блокирует анализ или загрузку HTML, но блокирует JavaScript, поскольку JavaScript часто используется для запроса влияния свойств CSS на элементы.

### Постройка CSSOM дерева

Вторым шагом в постройке критического пути является обработка CSS и постройка CSSOM дерева. CSS объектная модель похоже на DOM. DOM и CSSOM оба являются деревьями. Браузер преобразует правила CSS в карту стилей, которые он может понимать и с которыми может работать. Браузер проходит через каждый набор правил в CSS, создавая дерево узлов с родительскими, дочерними и родственными отношениями на основе селекторов CSS.

### Компиляция JS

После постройки CSSOM дерева браузер берется за скачанные JS файлы (спасибо сканеру предварительной загрузки) и парсит скрипты в абстрактное синтаксическое дерево. Некоторые браузерные движки берут это дерево и передают его в компилятор. Большая часть кода интерпретируется в основном потоке, но есть исключения, например код, выполняемый в веб-воркерах.

TODO: Написать про АСД (https://en.wikipedia.org/wiki/Abstract_syntax_tree)

### Построение дерева доступности

Браузер также создает дерево доступности, которое вспомогательные устройства используют для анализа и интерпретации контента. Объектная модель доступности (AOM) похожа на семантическую версию DOM. Браузер обновляет дерево доступности при обновлении DOM. Дерево доступности не может быть изменено самими вспомогательными технологиями.

Пока AOM не будет создан, контент недоступен для программ чтения с экрана.

## Рендеринг

Шаги рендеринга включают `стилизация`, `макет`, `отрисовка` и в некоторых случаях `композитинг`. 

### Стилизация (style)

Третий шаг в критическом пути рендера это объединения DOM и CSSOM в дерево рендеринга. Построение вычисляемого дерева стилей или дерева рендеринга начинается с корня дерева DOM, проходя через каждый видимый узел.

В дерево рендеринга попадают только видимые элементы, к примеру, элемент `<head>` и его дети или элементы с `display: none` не попадают в это дерево. Элементы со стилем `visibility: hidden` попадают в дерево рендеринга, так как они занимают место.

Каждый видимый узел имеет свой CSSOM правило, которое будет к нему применено. 

### Построение макета (layout)

Далее происходит процесс, посредством которого определяются размеры и расположение всех узлов в дереве рендеринга, а также определение размера и положения каждого объекта на странице.

`Перекомпоновка` - любое последующее определение размера и положения любой части страницы или всего документа.

Процесс определения размеров и положения элементов на странице начинается с корня дерева рендеринга.

Первое время, когда размер и позиция каждого элемента определены называется построение макета (`layout`). Последующие пересчеты называются перекомпоновка (`reflow`). Каринки загружаются асинхронно, а значит может быть ситуация, когда во время построения макета они ещё не загрузились, тогда для них оставляется пустое место. Когда картинка загружается происходит перекомпоновка, так как размер картинки там не был известен во время построения макета, то нужно пересчитать размеры и положения всех элементов, на которые могла бы повлиять картинка.

### Отрисовка (paint)

Последний этап заключается в отрисовке каждого узла, размеры и положение которых были вычислены на стадии построения макета, на экран. Отрисовка включает в себя рисование на экране каждой визуальной части элемента, включая текст, цвета, границы, тени и заменяемые элементы, такие как кнопки и изображения. Браузер должен делать это очень быстро. Чтобы перерисовка могла выполняться даже быстрее, чем первоначальная, рисунок на экране обычно разбивается на несколько слоев. Если это происходит, то необходима композиция. 

### Композитинг (compositing)

Когда разделы документа рисуются в разных слоях, перекрывая друг друга, необходима композиция, чтобы гарантировать, что они отрисовываются на экране в правильном порядке и содержимое отображается правильно.

Эти слои друг от друга не зависят, из-за чего изменение элемента в одном слое не затрагивает элементы из других слоёв, и перерисовывать их становится не нужно.

Именно из-за разнесения элементов по разным композиционным слоям свойство `transform` не так сильно нагружает браузер. Поэтому чтобы анимации не тормозили, их рекомендуется делать с применением `transform` и `opacity`.

Применение таких свойств, как, например, `transform`, «выносит» элемент на отдельный композитный слой, где положение элемента не зависит от других и не влияет на них.

## Интерактивность

Как только основной поток завершит рисование страницы, можно подумать, что все «все готово». Это не обязательно так. Если загрузка включает в себя JavaScript, который был правильно отложен и выполнен только после срабатывания события `onload`, основной поток может быть занят и недоступен для прокрутки, касания и других взаимодействий.

`Время до интерактивности` (`TTI`) — это измерение того, сколько времени прошло с момента первого запроса, который привел к поиску DNS и TCP-соединению, до момента, когда страница стала интерактивной. Под интерактивностью понимается момент времени после первой контентной отрисовки, когда страница отвечает на взаимодействие с пользователем в течение 50 мс. Если основной поток занят анализом, компиляцией и выполнением JavaScript, он недоступен и, следовательно, не может своевременно (менее 50 мс) реагировать на действия пользователя.

В нашем примере, возможно, изображение загрузилось быстро, но, возможно, размер файла Anotherscript.js составлял 2 МБ, а сетевое соединение нашего пользователя было медленным. В этом случае пользователь увидит страницу очень быстро, но не сможет прокручивать ее без рывков, пока скрипт не будет загружен, проанализирован и выполнен. Это не очень хороший пользовательский опыт. Не занимайте основной поток, как показано в этом примере WebPageTest:

![[Как_работают_браузеры_2.png]]