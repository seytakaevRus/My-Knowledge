---
tags:
  - roadmap
refs:
  - https://blog.xnim.me/event-loop-and-render-queue
  - https://habr.com/ru/articles/762618/
date: 2024-07-03
author: Ruslan Seit-Akaev
---
## Событийный цикл

Раньше ОС не поддерживали многопоточность и их цикл событий можно приблизительно описать как простой цикл:

```javascript
while (true) {
  if (execQueue.isNotEmpty()) {
    execQueue.pop().exec();
  }
}
```

Этот код использует весь процессор. Планировщики же современных ОС чрезвычайно сложны. У них есть расстановка приоритетов, очереди выполнения и многие другие технологии.

Описание `событийного цикла` можно начать с цикла, который проверяет есть ли какие-нибудь задачи, ожидающие выполнения:

![[Event-loop_1.png]]

> Список тригеров, которые могут положить задачу в `событийный цикл`:

1. Тег `<script>`;
2. Отложенные задачи `setTimeout`, `setInterval`, `requestIdleCallback`;
3. Обработчики событий из браузерного `API`: `click`, `mousedown`, `input`, `blur` и так далее
    - Некоторые из этих событий сгенерированы пользователем, такие как клики, скроллинг и так далее;
    - Некоторые из них сгенерированы из кода: `XmlHttpRequest` обработчик ответа, `fetch` разрешитель промисов и другие.
4. Изменение статуса у промиса;
5. Наблюдатели, `DOMMutationObserver`, `IntersectionObserver`;
6. `RequestAnimationFrame`.

Почти все, что описано выше планируется через `WebAPI` (браузерное `API`).

К примеру, у нас есть строчка кода:

```javascript
setTimeout(function a() {}, 100);
```

Когда мы выполняем `setTimeout`, то `WebAPI` откладывает задачу на `100 ms`. После `100 ms` `WebAPI` кладет `function a()` в очередь. Мы можем называть её `TaskQueue`. `Событийный цикл` получает эту задачу на следующем цикле и выполняет её.

И `JS` код и браузер должны иметь возможность работать с `DOM`.

`JS код`:

- Читает данные `DOM` элементов: размер, атрибуты, позиционирование и так далее;
- Изменяет атрибуты: `data-attr`, ширина, высота, позиционировании, стили `CSS` и так далее;
- Создает / удаляет `HTML` узлы.

А браузер рисует данные, чтобы пользователь мог увидеть изменения.

> Современные браузеры выполняют и `JS` код и отрисовку в одном потоке, кроме случаев, когда мы создаем `Web/Shared/Service` воркеры.

Это означает, что помимо просто задач должна быть и стадия "отрисовки" на схеме. Отрисовка это не одна операция, назовем это `render queue`:

![[Event-loop_2.png]]

Теперь есть два источника задач для выполнения `EventLoop`. Первый это `RenderQueue`, а второй это `SomeJSTasks`. Но как цикл должен выбирать задачи?

## Обновление экрана

В браузерах `событийный цикл` связан с фреймами. Фрейм можно рассматривать как единый снимок состояния экрана, который пользователь видит в данный момент.

> Браузеры стремятся отображать обновления на странице как можно быстрее, учитывая существующие ограничения в аппаратном и программном обеспечении

- Ограничения в аппаратном обеспечении: частота обновления экрана;
- Ограничения в программном обеспечении: настройки OS, настройки браузера, настройки энергосбережения и так далее.

> Подавляющее большинство браузеров/ОС поддерживает частоту `60 FPS` (кадров в секунду).

Это означает, что браузеры имеют временные интервалы `16,6 ms` (`1000 / 60`) для задач, прежде чем им придется отрисовать новый кадр (а отрисовка нового кадра также потребует времени).

## Очередь макрозадач и очередь микрозадач

Теперь пришло время разбить `SomeJSTasks` и понять как это работает.

Браузер использует две очереди, чтобы выполнить код:

1. `Task Queue` или `Macro Task Queue` предназначена для всех событий, отложенных задач и так далее;
2. `Micro Task Queue` это очередь для колбэков промиса как для отклоненных, так и для принятых и для `MutationObserver`.

### Очередь макрозадач

Когда браузер получает новую задачу, он кладет её в `Task Queue`. Каждый цикл `Event Loop` берет задачу из этой очереди и выполняет её. После того, как задача выполнена, если у браузера есть время (очередь отрисовки не содержит задач) `Event Loop` берёт следующую задачу с `Task Queue` и следующую задачу, пока в очереди отрисовки не появится задача.

Рассмотрим первый пример:

![[Event-loop_3.png]]

Есть три задачи: `A`, `B` и `C`. `Событийный цикл` берёт первую задачу и выполняет её. Это занимает `4 ms`. Затем `событийный цикл` проверяет остальные очереди (очередь микрозадач и очередь отрисовки). Они пустые. `Событийный цикл` выполняет задачу `B`. Это занимает `12 ms`. В сумме две задачи занимают `16 ms`. Затем браузер добавляет задачу в очередь отрисовки "нарисовать новый кадр" (новый кадр каждые `16,6 ms`). `Событийный цикл` проверяет очередь отрисовки и начинает выполнение задач в этой очереди. Это занимает приблизительно `1 ms`. После этого цикл возвращается к очереди макрозадач и выполняет последнюю задачу `C`.

> `Событийный цикл` не может предсказать, сколько времени будет выполняться задача. Более того, он не может приостановить задачу, чтобы отрисовать кадр, потому что движок браузера не знает, может ли он отрисовать изменения из пользовательского `JS` или это только подготовка, а не промежуточный результат. У нас просто нет `API` для этого.

Вот почему во время бесконечного цикла все зависает, управление не может перейти на другую задачу, к примеру, отрисовку нового кадра.

> Во время выполнения кода `JS` все изменения, вносимые `JS` не будут отрисованы в виде нового кадра до тех пор, пока макрозадача и все ожидающие микрозадачи не будут завершены. Но код `JS` может рассчитывать изменения `DOM`.

Другой пример:

![[Event-loop_4.png]]

Есть только две задачи `A` и `B`. Первая задача занимает `240 ms`. Раз новый кадр должен рисоваться каждый `16,6 ms`, то браузер не сможет отрисовать примерно `14` кадров. Когда задача `A` завершится, `событийный цикл` будет выполнять задачи из очереди отрисовки, чтобы нарисовать новый кадр. Важно отметить, что не смотря на то, что было потеряно `14` кадров, это не означает, что будут отрисованы `15` кадров подряд. Это будет один кадр.

Перед тем, как рассмотреть `Micro Task Queue` нужно поговорить о `Call Stack`.

### Стек вызовов

`Стек вызовов` - список, который показывает, какие функции с аргументами в данный момент вызываются и куда произойдет переход, когда текущая функция завершит своё выполнение.

```javascript
function findJinny() {
  debugger;
  console.log('Dialog with Jinny');
}

function goToTheCave() {
  findJinny();
}

function becomeAPrince() {
  goToTheCave();  
}

function findAFriend() {
   // ¯\_(ツ)_/¯
}

function startDndGame() {
  const friends = [];
  while (friends.length < 2) {
    friends.push(findAFriend());
  }
  becomeAPrince();
}
console.log(startDndGame());
```

Этот код остановится на инструкции `debugger`.

Стек начинается со строчки `console.log(startDndGame());`. На картинке она обозначена как `inline`. Далее в стек кладется функция `startDndGame` и функция `findAFriend`, она вызывается несколько раз. Этой функции нет на картинке, так как она выполнится и будет удалена из стека к тому времени, как управление дойдет до `debugger`.

![[Event-loop_5.png]]

> Когда `стек вызовов` становится пустым, то текущая задача выполнена.

> `Стек вызовов` в `JS` один

### Очередь микрозадач

Есть только два возможных источника микрозадач:

- колбэки у промисов `onResolved/onRejected`;
- колбэки `MutationObserver`.

> Микрозадача будет выполнена, как только стек вызовов опустеет.

Микрозадачи могут создавать другие микрозадачи, которые будут выполнены, когда стек вызовов опустеет. Каждая микрозадача откладывает выполнение новой макрозадачи или отрисовки кадра.

Рассмотрим пример, где у нас есть `4` микрозадачи в очереди микрозадач:

![[Event-loop_6.png]]

Первая микрозадача на выполнение это `A`. Она занимает `200 ms` и у нас есть задачи в очереди на отрисовку. Однако их выполнения будет отложены, потому что в очереди микрозадач есть ещё 3 задачи. Это означает, что после выполнения `A` событийный цикл будет выполнять `B`, `C` и наконец `D`. Когда очередь микрозадач опустеет, то событийный цикл отрисует новый кадр. А до тех пор, пока они не выполнены, браузерное `UI` будет заблокировано и не-интерактивно.

>Последующие микрозадачи могут заблокировать пользовательский интерфейс сайта и сделать страницу неинтерактивной.

Микрозадачи могут быть как преимуществом, так и недостатком. Например, когда `MutationObserver` вызывает свой колбэк в соответствии с изменениями `DOM`, пользователь не увидит изменения на странице до завершения колбэка.

Обновленная схема событийного цикла выглядит так:

![[Event-loop_7.png]]

## Что выполняется внутри очереди отрисовки?

Отрисовка кадра это не одна операция. Она имеет несколько стадий и каждая стадия может быть поделена на подстадии. Ниже представлена схема стадий, пройдя через которые браузер рисует новый кадр:

![[Event-loop_8.png]]

### Request Animation Frame (RAF)

![[Event-loop_9.png]]

Браузер готов начать отрисовка, мы можем подписаться на колбэк `requestAnimationFrame` и вычислить или подготовить кадр для шага анимации.

> `requestAnimationFrame` хорошо подходит для работы с анимацией или планирования некоторых изменений в `DOM` непосредственно перед отрисовкой кадра.

> Интересные факты о `RAF`:

1. Колбэк `RAF` имеет аргумент `DOMHighResTimeStamp`, который представляет из себя количество милисекунд, прошедших с момента "начала времени", который является началом существования документа. Это значит, что нет нужны внутри колбэка использовать `performance.now()`, так как он уже есть;
2. `RAF` возвращает дескриптор (`id`), значит можно отменить колбэк `RAF` при помощи `cancelAnimationFrame` (как `setTimeout` или `setInterval`);
3. Если пользователь меняет вкладку или сворачивает браузер, то повторного рендеринга не будет, значит не будет и вызова `RAF`;
4. `JS` код, который изменяет размер элементов или считывает свойства элементов, может принудительно вызывать `requestAnimationFrame`;
5. Если обновление анимации выполняется внутри этого колбэка, то браузер может её оптимизировать и анимация будет выглядить более плавной.
6. Также анимации в неактивных вкладках останавливаются, позволяя `CPU` отдохнуть;
7. Код ниже показывает как часто браузер отрисовывает кадры:

```javascript
const checkRequestAnimationDiff = () => {
  let prev;
  
  function call() {
    requestAnimationFrame((timestamp) => {
        if (prev) {
          console.log(timestamp - prev); 
          // It should be around 16.6 ms for 60FPS
        }
        prev = timestamp;
        call();
    });
  }
  
  call();
}
checkRequestAnimationDiff();
```

### Стили (пересчет)

> Браузер пересчитывает какие стили, которые должны быть применены. Эта стадия также рассчитывает какие `media queries` должны быть активны.

Пересчет включает в себя оба непосредственных изменения:

- `a.style.left = '10px'`;
- и те, что описаны в файлах `CSS`, к примеру, `element.classList.add('my-styles-class')`.

### Макет (верстка)

> Здесь рассчитываются слои, позиционирование элементов, их размеров и их взаимное влияние друг на друга. Чем больше элементов `DOM` на странице, тем сложнее операция.

`Макет` - достаточно болезненная операция для современных сайтов, эта стадия пересчитывается каждый раз, когда вы:

1. Читаете свойства, связанные с размером и положением элемента (`offsetWidth`, `offsetLeft`, `getBoundingClientRect` и так далее);
2. Изменяем свойства, который связаны с их размером и позиционированием, кроме некоторых из свойств `transform` и `will-change`.

> `JS` код может вызывать `перекомпоновку` (`force layout`) это процесс, который включает в себя две стадии: повторное вычисление стилей и повторное построение. Методы, который могут это делать описаны тут: https://gist.github.com/paulirish/5d52fb081b3570c81e3a

> Когда вызывается `перекомпоновка`, браузер останавливает главный поток `JS`, несмотря на то, что стек ещё не пустой.

К примеру:

```javascript
div1.style.height = "200px"; // Change element size
var height1 = div1.clientHeight; // Read property
```

Браузер не может вычислить `clientHeight` нашего `div1` без повторных вычислений его истинного размера. В этом случае браузер останавливает `JS` код и выполняет:

- Стадию стилей, чтобы проверить, что следует изменить;
- Стадию макета, чтобы пересчитать размеры. Рассчитывается макет не только для элементов до `div1`, но и после.

Браузеры пытаются не вызывать `перекомпоновку` каждый раз отдельно, а стараются их группировать:

```javascript
div1.style.height = "200px";
var height1 = div1.clientHeight; // <-- layout 1
div2.style.margin = "300px";
var height2 = div2.clientHeight; // <-- layout 2
```

Браузер не будет делать две `перекомпоновки`, поэтому он сгруппирует код таким образом:

```javascript
div1.style.height = "200px";
div2.style.margin = "300px";
var height1 = div1.clientHeight; // <-- layout 1
var height2 = div2.clientHeight;
```

`Перекомпоновка` (`force layout`) может быть вызвана как в микрозадаче, так и макрозадаче:

![[Event-loop_10.png]]

Советы как можно оптимизировать стадию макет:

1. Уменьшить количество `DOM` узлов;
2. Группировать операции чтения/записи, чтобы избавиться от ненужных `перекомпоновок`;
3. Заменить операции, которые вызывают `перекомпоновку`, операциями, который вызывают вычисление заново стадию композиция (`Composite`).

### Рисование

![[Event-loop_11.png]]

>У нас есть элемент, его стили, его позиция на экране и его размер. Теперь нужно применить цвет, задний фон, нужно его нарисовать.

Обычно этот процесс не занимает много времени, но первая отрисовка может длиться долго. После этой стадии мы можем "физически" нарисовать кадр.

### Композиция

![[Event-loop_12.png]]

> `Композиция` - единственный этап, который по умолчанию работает на графическом процессоре. На этом этапе браузер выполняет только определенные стили `CSS`, такие как "трансформация".

Современные браузеры могут перемещать часть операций на `GPU` по своему усмотрению.

`transform` это лучший выбор для сложных анимаций:

1. Мы не вызываем `перекомпоновку` каждый кадр, мы сохраняем время `CPU;

### Как оптимизировать отрисовку кадра?

> Самая сложная операция по отрисовке кадра - макет. Если есть сложная анимация, то каждый рендеринг может потребовать смещения всех неэффективных элементов `DOM`, а так как это занимает много времени, то можно потерять кадры, а значит и производительность сайта.

Чтобы улучшить производительность, можно пропускать некоторые стадии.

> Мы можем пропускать стадию макета, если изменяем цвет, задний фон картинки и так далее.

![[Event-loop_13.png]]

> Мы можем пропускать стадии макета и отрисовки, когда используем свойство `transform` и не считываем свойство из `DOM` элементов.

![[Event-loop_14.png]]

> Подводят итог всем советам:

1. Перемещать анимации с `JS` на `CSS`. Выполнение дополнительно `JS` кода небесплатно, а так часть работы можно скинуть на `GPU`;
2. Анимировать при помощи `transform` для движения объектов;
3. Использовать `will-change` TODO: прочитать про это свойство;
4. Использовать `requestAnimationFrame`, чтобы планировать изменения в новом кадре;
5. Комбинировать чтение/запись `CSS` свойств;
6. Обращать внимание на свойства, которые могут приводить к `перекомпоновке`;
7. Использовать профайлер (вкладка `Perfomance`), чтобы понять какая фаза сколько времени занимает.

## Алгоритм, по которому `событийный цикл` определяет, что делать дальше

1. Сначала `событийный цикл` выполняет все синхронные задачи;
2. Потом выполняются все задачи из очереди микрозадач;
3. После их выполнения - очередь микрозадач очищается;
4. Затем берется одна макрозадача из списка и она выполняется;
5. После выполнения цикл смотрит, нужно ли нарисовать следующий кадр;
6. Если нужно, то кадр рисуется;
7. Все начинается снова с первого пункта.

### Эксперимент 1

```javascript
console.log("Step 1: In global scope")

setTimeout(() => console.log("Step 2: In setTimeout"));

new Promise((resolve) => {
  resolve();
  console.log('Step 3: In promise constructor');
}).then(() => console.log('Step 4: In then'));

setTimeout(() => console.log("Step 5: In another setTimeout"))
```

В консоли будет:

```
Step 1: In global scope
Step 3: In promise constructor
Step 4: In then
Step 2: In setTimeout
Step 5: In another setTimeout
```

- Сначала выполнились все синхронные операции: `Step 1`, `Step 3` (колбэк внутри конструктора промиса является синхронным);
- Потом выполнились все микрозадачи `Step 4`;
- Затем выполнились все макрозадачи `Step 2`, `Step 5`.

Стоит заметить, что задачи находятся в очередях, а значит первая задача выполнится та, которая зашла раньше всего.

![[Event-loop_15.png]]

### Эксперимент 2

Если добавить второй `then` к промису:

```javascript
console.log("Step 1: In global scope")

setTimeout(() => console.log("Step 2: In setTimeout"));

new Promise((resolve) => {
  resolve();
  console.log('Step 3: In promise constructor');
}).then(() => console.log('Step 4: In then'))
  .then(() => console.log('Step 5: In another then'));

setTimeout(() => console.log("Step 6: In another setTimeout"))
```

То второй `then` просто выполнится после первого:

```
Step 1: In global scope
Step 3: In promise constructor
Step 4: In then
Step 5: In another then
Step 2: In setTimeout
Step 6: In another setTimeout
```

![[Event-loop_16.png]]

### Эксперимент 3

Теперь промисов будет два.

```javascript
console.log("Step 1: In global scope")

setTimeout(() => console.log("Step 2: In setTimeout"));

new Promise((resolve) => {
  console.log('Step 3: In promise constructor');
  resolve();
}).then(() => console.log('Step 4: In then'))
  .then(() => console.log('Step 5: In another then'));

setTimeout(() => console.log("Step 6: In another setTimeout"))

new Promise((resolve) => {
  console.log('Step 7: In promise constructor');
  resolve();
}).then(() => console.log('Step 8: In then'))
  .then(() => console.log('Step 9: In another then'));
```

В этот раз код с микрозадачами отработает чуть иначе.

```
Step 1: In global scope
Step 3: In promise constructor
Step 7: In promise constructor
Step 4: In then
Step 8: In then
Step 5: In another then
Step 9: In another then
Step 2: In setTimeout
Step 6: In another setTimeout
```

Вместо `Step 4`, `Step 5`, `Step 8` и `Step 9`. Мы видим `Step 4`, `Step 8`, `Step 5`, `Step 9`. 

Интерпретатор `JS` выполняет код шаг за шагом. Он увидит, что у нас есть `then` и поместит их в очередь микрозадач, когда микрозадачи отработали, интерпретатор увидел ещё один `then` и опять поместил его в очередь микрозадач. Таким образом все `then`, которые были после первых `then` выполнялись в ряд после того как первичные `then` отработали.

![[Event-loop_17.png]]
### Эксперимент 4

Теперь будет промис, внутри которого будет макрозадача.

```javascript
setTimeout(() => console.log('Step 1: In setTimeout'));

new Promise(resolve => {
  console.log('Step 2: In promise constructor');
  resolve();
}).then(() => {
  console.log('Step 3: In then');
  setTimeout(() => console.log('Step 4: In setTimeout (inside of "then")'));
});

setTimeout(() => console.log('Step 5: In another setTimeout'));
```

Ответом будет:

```
Step 2: In promise constructor
Step 3: In then
Step 1: In setTimeout
Step 5: In another setTimeout
Step 4: In setTimeout (inside of "then")
```

Тут все просто, когда цикл выполнит микрозадачу, то в очереди макрозадач уже будут лежать `Step 1` и `Step 5`, а значит `Step 4` добавиться в конец макрозадач.

### Эксперимент 5

Теперь в макрозадаче будет микрозадача.

```javascript
setTimeout(() => console.log('Step 1: In setTimeout'));
setTimeout(() => {
  new Promise(resolve => {
    console.log('Step 2: In promise constructor (inside setTimeout)');
    resolve();
  }).then(() => console.log('Step 3: In then (inside setTimeout)'));
});

new Promise(resolve => {
  console.log('Step 4: In promise constructor');
  resolve();
}).then(() => {
  console.log('Step 5: In then');
});

setTimeout(() => console.log('Step 6: In another setTimeout'));
```

- Сначала выполняется синхронный код `Step 4`;
- После того, как интерпретатор пробежал по коду в очереди макрозадач лежит `Step 1`, промис внутри `setTimeout`, `Step 6`, а в очереди микрозадач лежит `Step 5`;
- Далее `Step 5`, потому что выполняются все микрозадачи;
- Далее `Step 1`, первая в очереди макро задач;
- Далее `Step 2`, потому что это синхронный код, в очередь микрозадачи попадает `Step 3`;
- Далее `Step 3`, потому что микрозадачи имеют приоритет над макрозадачами;
- Далее `Step 6`, потому что последняя макрозадача.

```
Step 4: In promise constructor
Step 5: In then
Step 1: In setTimeout
Step 2: In promise constructor (inside setTimeout)
Step 3: In then (inside setTimeout)
Step 6: In another setTimeout
```

> Если микрозадач будет очень много, то управление не перейдет к макрозадачам или отрисовке нового кадра, поэтому это может заблокировать.

### Эксперимент 6

```javascript
console.log(1);

setTimeout (() => {
  console.log(2);
});

const promise = new Promise((res) => {
  console.log(3);

  res();
});


Promise.resolve().then(() => console.log(4));

promise
  .then(() => console.log(5))
  .then(() => console.log(6));

queueMicrotask(() => console.log(7)); // put callback in microtask queue

requestAnimationFrame(() => console.log(8)); // macrotask or part of rendering, so executes after all micro and macro tasks

requestIdleCallback(() => console.log(9)); // something, that executes when browser staying in idle stage

console.log(10);
```

```
1
3
10
4
5
7
6
2
8
9
```

### Эксперимент 7

```javascript
console.log(1);

requestIdleCallback(() => {
  console.log(6);
});

setTimeout(() => {
  console.log(2);
});

requestAnimationFrame(() => {
  console.log(3);
});

queueMicrotask(() => console.log(4));

const p = new Promise((rs, rj) => {
  console.log(7);
  rs();
  console.log(20);
  rj();
});

p.then(() => console.log(8)).catch((er) => console.log(er));

queueMicrotask(() => console.log(10));

p.then(() => console.log(9))
  .finally(() => console.log(11))
  .then(() => console.log(12));

setTimeout(() => {
  console.log(5);
}, 0);
```