---
tags:
  - roadmap
refs:
  - https://www.zhenghao.io/posts/object-vs-map
  - https://www.builder.io/blog/maps
date: 2024-05-22
author: Ruslan Seit-Akaev
---
## Короткий ответ

- Использовать `Object` для записей, где мы имеем фиксированное и конечное число полей/свойство и название этих полей/свойств известно, например, объект конфигурации. И вообще все, что предназначено для одноразового использования;
- Использовать `Map` для словарей или хеш-мапов, где количество полей/свойств является динамической величиной, с частыми обновлениями, чьи названия полей/свойств неизвестны сейчас, например, `event emitter`.

## Почему `Object` проигрывает `Map`

Одна из главных недостатков, которые есть у объектов в `JS` это то, что в качестве ключей могут выступать только строки и символы. Другие типы будут неявно преобразованы в строки посредством вызова метода `toString`.

```javascript
const foo = []
const bar = {}
const obj = {[foo]: 'foo', [bar]: 'bar'}

console.log(obj) // {"": 'foo', [object Object]: 'bar'}
```

### Нежеланное наследование

До `ES6` был один способ создание хеш-мапа.

```javascript
const hashMap = {}
```

Выглядит как пустой объект, но благодаря прототипному наследованию у этого объекта можно вызывать метода `hasOwnProperty`, `toString`, `constructor` и т.д., хотя эти методы у `hashMap` нигде явно не объявлены.

Из-за такого наследования появляются два типа полей:
- те поля, которые есть в самом объекте, `его собственные` поля;
- те поля, которые есть в прототипной цепочке.

Поэтому, чтобы убедится, что поле принадлежит самому объекту, а не взято из прототипной цепочки нужно использовать метод `hasOwnProperty`.

Да и благодаря тому, как это работает в `JS`, любые изменения в `Object.prototype` во время выполнения кода будут влиять на все объекты. 

К счастью, можно отказаться от такого наследования, создав объект через `Object.create(null)`, таким образом объект ничего не наследует от `Object.prototype`.

### Коллизия имен

Когда у объекта есть свойство, чье имя такое же, как и имя свойства в его прототипе, это может вызвать путаницу и сломать программу.

К примеру, у `obj` может быть свойство `hasOwnProperty`, которое определил сам пользователь, но также свойство `hasOwnProperty` есть и у `Object.prototype`.

```javascript
const a = {};

a.hasOwnProperty = 'virus'
a.title = 5

a.hasOwnProperty('title') // Этот код упадет с ошибкой "a.hasOwnProperty is not a function"

const b = {}

b.title = 5
b.hasOwnProperty('title') // Этот код отработает корректно
```

Поэтому нужно использовать запись `Object.prototype.hasOwnProperty.call(a, 'title')`.