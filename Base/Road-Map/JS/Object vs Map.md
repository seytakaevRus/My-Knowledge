---
tags:
  - roadmap
refs:
  - https://www.zhenghao.io/posts/object-vs-map
  - https://www.builder.io/blog/maps
date: 2024-05-22
author: Ruslan Seit-Akaev
---
## Короткий ответ

### Использовать `Object`

- для записей, где имеется фиксированное и конечное число полей/свойство и название этих полей/свойств известно например, объект конфигурации;
- объект будет использован один раз и не будет подвергаться частым обновлениям;
- частые обновления допустимы, только если в качестве ключей используются [[Object vs Map#Ключи числа-строки|числа строки]] (индексы), возможно, тут даже подойдут массивы, но это зависит от ситуации.

### Использовать `Map`

- для словарей или `хеш-мапов`, где количество полей/свойств является динамической величиной, с частыми обновлениями, чьи названия полей/свойств неизвестны сейчас, например, `event emitter`;
- более эффективен по памяти, чем `Object`;
- более понятный и простой `API`;
- нет [[Object vs Map#Нет нежеланного наследования и нет коллизии имен|прототипного наследования]] такого как у `Object`.

## Почему `Object` проигрывает `Map`

Одна из главных недостатков, которые есть у объектов в `JS` это то, что в качестве ключей могут выступать только строки и символы. Другие типы будут неявно преобразованы в строки посредством вызова метода `toString`.

```javascript
const foo = [];
const bar = {};
const obj = {[foo]: 'foo', [bar]: 'bar'};

console.log(obj); // {"": 'foo', [object Object]: 'bar'}
```

### Нежеланное наследование

До `ES6` был один способ создание хеш-мапа.

```javascript
const hashMap = {};
```

Выглядит как пустой объект, но благодаря прототипному наследованию у этого объекта можно вызывать метода `hasOwnProperty`, `toString`, `constructor` и т.д., хотя эти методы у `hashMap` нигде явно не объявлены.

Из-за такого наследования появляются два типа полей:
- те поля, которые есть в самом объекте, `его собственные` поля;
- те поля, которые есть в прототипной цепочке.

Поэтому, чтобы убедится, что поле принадлежит самому объекту, а не взято из прототипной цепочки нужно использовать метод `hasOwnProperty`.

Да и благодаря тому, как это работает в `JS`, любые изменения в `Object.prototype` во время выполнения кода будут влиять на все объекты. 

К счастью, можно отказаться от такого наследования, создав объект через `Object.create(null)`, таким образом объект ничего не наследует от `Object.prototype`.

### Наличие коллизии имен

Когда у объекта есть свойство, чье имя такое же, как и имя свойства в его прототипе, это может вызвать путаницу и сломать программу.

К примеру, у `obj` может быть свойство `hasOwnProperty`, которое определил сам пользователь, но также свойство `hasOwnProperty` есть и у `Object.prototype`.

```javascript
const a = {};

a.hasOwnProperty = 'virus';
a.title = 5;

a.hasOwnProperty('title'); // Этот код упадет с ошибкой "a.hasOwnProperty is not a function"

const b = {};

b.title = 5;
b.hasOwnProperty('title'); // Этот код отработает корректно
```

Поэтому нужно использовать запись `Object.prototype.hasOwnProperty.call(a, 'title')`, но можно использовать и запись покороче `Object.hashOwn(a, 'title')`.

### Отсутствия размера объекта

Нет `API` для получения у `Object` информации о количестве свойств в нем, поэтому можно использовать `Object.keys(hashMap).length`, такая операция занимает `O(n)` по времени, где `n` - количество свойств у `hashMap`.

### Объект не итерируемый по умолчанию

Чтобы это сделать нужно использовать `for..in`, а не `for..of`, так как по умолчанию объект не итерируемый до тех пор, пока мы сами не определим `Symbol.iterator`.

Но проблема с `for..in` заключается в том, что он может доставать ключи из прототипа объекта, если дескриптор `enumerable` этого свойства  выставлен в `true`.

```javascript
const a = {
  title: 15
};

Object.prototype.title2 = 13;

for (key in a) {
  console.log(key); // title title2
}

Object.getOwnPropertyDescriptor(Object.prototype, 'title2');
// {value: 13, writable: true, enumerable: true, configurable: true}
```

Значит нужно использовать дополнительную проверку с использованием `Object.prototype.hasOwnProperty.call`/`Object.hashOwn`.

Можно использовать `Object.keys`, `Object.values`, `Object.entries`, чтобы получить список, который можно проитерировать, но это дает дополнительную нагрузку, которая занимает `O(n)`.

Наконец, порядок вставки не соблюдается. В большинстве браузеров целочисленные ключи сортируются по возрастанию и имеют приоритет над строковыми ключами, даже если строковые ключи были вставлены перед целочисленными.

```javascript
const obj = {};

obj.foo = 'first';
obj[2] = 'second';
obj[1] = 'last';

console.log(obj); // {1: 'last', 2: 'second', foo: 'first'}
```

### Нельзя удалить все свойства

Нет простого способа, чтобы полностью очистить объект, нужно удалять каждое свойство соответственно с оператором `delete`, который работает из-за особенности хранения объектов в `JS` и дополнительных проверок. Хотя и не намного быстрее по сравнению с `Map.prototype.delete`.

### Специфичная проверка существования свойства

Чтобы проверить существования свойства в объекте мы не можем полагаться на точечную/скобочную нотацию, потому что по умолчанию значение будет равно `undefined`. А в объекте пользователь мог сам указать ключ, у которого значение будет `undefined`, поэтому нужно использовать методы `Object.prototype.hasOwnProperty` или `Object.hasOwn`.

## Почему `Map` больше подходит для `хеш-мапа`

`ES6` принес нам `Map` и первое, что следует сказать, `Map` позволяет в качестве ключа использовать не только строки или символы, но и любые типы данных.

Однако, если использовать `Map` для хранения метаданных для объектов, то нужно использовать `WeakMap`, чтобы избежать утечек памяти.

TODO: Написать про `WeakMap` и `WeakSet`.

### Нет нежеланного наследования и нет коллизии имен

Для извлечения данных из `Map` используется метод `Map.prototype.get`, который не ищет свойство в цепочке прототипов, как это делает объект, код ниже это доказывает.

```javascript
const map = new Map();

map.set('title', 10);
Map.prototype.title = 555;

console.log(map.title); // 555
map.get('title'); // 10

map.delete('title');

console.log(map.title); // 555
map.get('title'); // undefined
```

### Есть размер

У `Map` есть свойство `Map.prototype.size`, которое показывает сколько пар есть в нем. И это намного быстрее и проще, чем получать массив из ключей у объекта, затем получать их длину.

### Он итерируемый

По умолчанию `Map` итерируемый, а значит для его перебора можно использовать `for..of`.

Либо можно использовать деструктуризацию по типу:

```javascript
const [[firstKey, firstValue]] = map;
```

А также сохраняет последовательность добавления свойств.

### Можно удалять все свойства

При помощи метода `Map.prototype.clear` это можно сделать и данная операция куда быстрее, чем делать `delete` каждого свойства в объекте.

### Удобная проверка существования свойства

`Map.prototype.has` проверяет наличие заданной записи, что удобнее, чем использовать `Object.prototype.hasOwnProperty`/`Object.hasOwn` для объектов.

## О производительности

Я сталкивался с задачами на `Leetcode`, где нужно использовать `хеш-мап` и, если использовать объект в этих целях, то один из тестов падает с ошибкой `Time Limit Exceeded`, а если вместо объекта использовать `Map`, то тесты проходят. Например, в задачах [[2461]] и [[2653]] такая ситуация наблюдалась.

В большинстве случаев `Map` быстрее, чем `Object`, но есть нюансы, о которых будет рассказано ниже.

Бенчмарки производились при помощи этого приложения https://csb-yuu1dm.netlify.app/, в первой статье автор рассказывает про него. А код самих бенчмарков лежит тут https://codesandbox.io/p/sandbox/still-glitter-yuu1dm?file=%2Fsrc%2Findex.js

TODO: разобрать этот код и перенести в obsidian

Автор проводит тесты с тремя типами ключей:
- ключи строки, например, `yekwl7caqejth7aawelo4`;
- ключи числа-строки, например, `123`;
- числовые строки, которые сгенерированы при помощи `Math.random().toString()`, например, `0.4024025689756525`.

В качестве операций были выбраны вставка, перебор и чтение значения (сделаны вместе), удаление всех свойств. 

Вставка и перебор измеряются как `количество операций, чье время выполнение не превысило duration / время выполнение этих операций`, а удаление всех свойств измеряется во времени, которое было на него затрачено в `ms`.

Есть `2` метрики у объектов/мапов:
- их размер, то есть количество свойств внутри них;
- их вложенность, в каждой такой структуре создается еще одна с тем же размером, но с глубиной на `1` меньше.

Здесь рассматриваются только плоские структуры с глубиной равной `1`, автор говорит, что при увеличение глубины характеристики производительности остаются в основном такими же, пока общее количество записей одинаково, независимо от того, сколько уровней вложенности у нас есть.

Например, если размер структуры равен `100`, а глубина равна `3`, общее количество записей равно одному миллиону (`100 * 100 * 100`). Результаты практически такие же, по сравнению с `1000000` для размера и `1` для глубины.
### Ключи строки

Здесь `Map` выигрывает во всех трех операциях, как на малом размере `Object`/`Map`.

![[Object-vs-Map_1.png]]

Так и на размере больше. На `Leetcode`часто можно встретить условие длины массива равное `10^5`, поэтому тут и был выбран такой размер структуры.

![[Object-vs-Map_2.png]]

### Ключи числа-строки

Автор решил провести бенчмарк на этот типа ключей, так как `V8` внутренне оптимизирует свойства с целочисленным индексом https://v8.dev/blog/fast-properties#named-properties-vs.-elements.

Влияние увеличения длины диапазона чисел на производительность замечено не было. На малом размере у структур `Map` выигрывает в добавлении у `Object`.  

![[Object-vs-Map_3.png]]

Но с увеличением размера структур выигрыш при добавлении у `Object` становится более ощутимым, хотя выигрыш при переборе все-таки останется за `Map`.

![[Object-vs-Map_4.png]]

![[Object-vs-Map_5.png]]

Из этого можно сделать вывод, что для чисел-строк (индексов) при большом количестве и частом взаимодействии лучше использовать `Object`, а не `Map`.

### Числовые строки, сгенерированные при помощи `Math.random`

Здесь показатели похожи на [[Object vs Map#Ключи строки|ключи строки]].

При небольшом размере разрыв выходит почти в `2` раза у `Map`над `Object`, а при большом размере разрыв становится меньше и меньше.

## О памяти

Автор первой статьи пишет, что `Map` занимает меньше памяти, чем `Object`, причем это не зависит от типа ключа, который был использован. Это происходит потому что `Map` не хранит информацию о дескрипторах, таких как `writable` / `enumerable` / `configurable`, как это делает `Object`.