---
tags:
  - roadmap
refs:
  - https://www.zhenghao.io/posts/object-vs-map
  - https://www.builder.io/blog/maps
date: 2024-05-22
author: Ruslan Seit-Akaev
---
## Короткий ответ

- Использовать `Object` для записей, где мы имеем фиксированное и конечное число полей/свойство и название этих полей/свойств известно, например, объект конфигурации. И вообще все, что предназначено для одноразового использования;
- Использовать `Map` для словарей или хеш-мапов, где количество полей/свойств является динамической величиной, с частыми обновлениями, чьи названия полей/свойств неизвестны сейчас, например, `event emitter`.

## Почему `Object` проигрывает `Map`

Одна из главных недостатков, которые есть у объектов в `JS` это то, что в качестве ключей могут выступать только строки и символы. Другие типы будут неявно преобразованы в строки посредством вызова метода `toString`.

```javascript
const foo = []
const bar = {}
const obj = {[foo]: 'foo', [bar]: 'bar'}

console.log(obj) // {"": 'foo', [object Object]: 'bar'}
```

### Нежеланное наследование

До `ES6` был один способ создание хеш-мапа.

```javascript
const hashMap = {}
```

Выглядит как пустой объект, но благодаря прототипному наследованию у этого объекта можно вызывать метода `hasOwnProperty`, `toString`, `constructor` и т.д., хотя эти методы у `hashMap` нигде явно не объявлены.

Из-за такого наследования появляются два типа полей:
- те поля, которые есть в самом объекте, `его собственные` поля;
- те поля, которые есть в прототипной цепочке.

Поэтому, чтобы убедится, что поле принадлежит самому объекту, а не взято из прототипной цепочки нужно использовать метод `hasOwnProperty`.

Да и благодаря тому, как это работает в `JS`, любые изменения в `Object.prototype` во время выполнения кода будут влиять на все объекты. 

К счастью, можно отказаться от такого наследования, создав объект через `Object.create(null)`, таким образом объект ничего не наследует от `Object.prototype`.

### Коллизия имен

Когда у объекта есть свойство, чье имя такое же, как и имя свойства в его прототипе, это может вызвать путаницу и сломать программу.

К примеру, у `obj` может быть свойство `hasOwnProperty`, которое определил сам пользователь, но также свойство `hasOwnProperty` есть и у `Object.prototype`.

```javascript
const a = {};

a.hasOwnProperty = 'virus'
a.title = 5

a.hasOwnProperty('title') // Этот код упадет с ошибкой "a.hasOwnProperty is not a function"

const b = {}

b.title = 5
b.hasOwnProperty('title') // Этот код отработает корректно
```

Поэтому нужно использовать запись `Object.prototype.hasOwnProperty.call(a, 'title')`, но можно использовать и запись покороче `Object.hashOwn(a, 'title')`.

### Отсутствия размера объекта

Нет `API` для получения у `Object` информации о количестве свойств в нем, поэтому можно использовать `Object.keys(hashMap).length`, такая операция занимает `O(n)` по времени, где `n` - количество свойств у `hashMap`.

### Перебор объекта

Чтобы это сделать нужно использовать `for..in`, а не `for..of`, так как по умолчанию объект не итерируемый до тех пор, пока мы сами не определим `Symbol.iterator`.

Можно использовать `Object.keys`, `Object.values`, `Object.entries`, чтобы получить список, который можно проитерировать, но это дает дополнительную нагрузку, которая занимает `O(n)`.

Наконец, порядок вставки не соблюдается. В большинстве браузеров целочисленные ключи сортируются по возрастанию и имеют приоритет над строковыми ключами, даже если строковые ключи были вставлены перед целочисленными.

```javascript
const obj = {}

obj.foo = 'first'
obj[2] = 'second'
obj[1] = 'last'

console.log(obj) // {1: 'last', 2: 'second', foo: 'first'}
```

### Удаление всех свойств

Нет простого способа, чтобы полностью очистить объект, нужно удалять каждое свойство соответственно с оператором `delete`, который работает из-за особенности хранения объектов в `JS` и дополнительных проверок. Хотя по сравнению с `Map.prototype.delete` не так и медленен, а иногда даже быстрее.

### Проверка существования свойства

Чтобы проверить существования свойства в объекте мы не можем полагаться на точечную/скобочную нотацию, потому что по умолчанию значение будет равно `undefined`. А в объекте пользователь мог сам указать ключ, у которого значение будет `undefined`, поэтому нужно использовать методы `Object.prototype.hasOwnProperty` или `Object.hasOwn`.

## Почему `Map` больше подходит для `хеш-мапа`

`ES6` принес нам `Map` и первое, что следует сказать, `Map` позволяет в качестве ключа использовать не только строки или символы, но и любые типы данных.

TODO: Допереводить статью из ссылок выше.