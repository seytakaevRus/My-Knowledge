---
tags:
  - roadmap
refs:
  - https://www.youtube.com/watch?v=5LH5M5wvz34
date: 2024-07-09
author: Ruslan Seit-Akaev
---
## Что такое React?

`React` - `JavaScript` библиотека для создания пользовательских интерфейсов (не только `WEB`). 

### Почему библиотека?

Библиотекой его считают, потому что в нём нет готового решения для маршрутизации, управления состоянием, взаимодействия с сервером и других аспектов разработки приложений. `React` фокусируется на создании пользовательских интерфейсов и предоставляет эффективный способ управления ими через виртуальный `DOM`.

### Библиотека vs фреймворк

`Библиотека` - помогает решить пару задач, например, визуализировать `HTML` из `JS` и синхронизировать его с состоянием приложения.

`Фреймворк` - система библиотек, которые связаны между собой. Определяют весь проект, от того, как он что делает, до, возможно, файловой структуры и соглашений об именах.

### Почему не только `WEB`?

`Рендер` определяет то, как приложение будет отрисовано. `Рендер` можно переписать под определенные нужды, к примеру, под `VR` или под мобилки.

## Основы `React`

### Компонентный подход

Строительными блоками `React` являются `React-элементы`, который представляют из себя `JavaScript` объекты. Бывают:

- `React Element DOM`;
- `React Component`.

#### `React Element DOM`

Эти элементы не одно и то же, что и `DOM` элементы, потому что `React` взаимодействует с `Virtual DOM`, а не напрямую с реальным `DOM`. Называются также, как и реальные `DOM` элементы. На основе `React Element DOM` будут строиться элементы в реальном `DOM`.

Для создания такого элемента можно использовать `React.createElement`.

```js
return React.createElement('span');
```

 Свойство `children` задает детей у элементов, то есть в браузере будет `<span>Hello</span>`

```js
return React.createElement('span', { children: 'Hello' });
```

Но такой синтаксис неудобен, поэтому был создан [[Базовый#`JSX`|JSX]].

> Названия элементов начинаются с маленькой буквы.

#### `React Component`

`Компонент` состоит из `React Element DOM` и из других `компонентов`. Компоненты создаются для того, чтобы потом переиспользоваться. Представлены двумя группами:

- Классовые компоненты;
- Функциональные компоненты.

Классовый компонент выглядит как класс:

```js
class First extends React.Component {
  render() {
    //
  }
}
```

Функциональный компонент выглядит как функция или стрелочная функция:

```js
function First() {
  return ...
}

const First = () => {
  return ...
}
```

`return` возвращает, либо `компонент`, либо `null`.

> Всегда стоит использовать функциональные компоненты, исключением является `ErrorBoundary`, который на данный момент может быть только классовым.

> Названия компонентов начинаются с большой буквы все, что с маленькой буквы `React` распознает как элементы. В названии лучше не писать `Component`, итак ясно, что код выше является компонентом.

### `JSX`

`JSX` - синтаксический сахар, который существует только в `React`. В браузере же `JSX` не существует и он превращается в `JS` код.

Константные данные отображаются таким образом

```js
<span>Hello</span>
```

Динамические данные отображаются при помощи фигурных скобок. В таких скобках можно указывать любой `JS код`.

```js
return <span>{title}</span>
return <span>{title ?? "Unknown Film"}</span>
```

Фигурные скобки стоит использовать в одном из двух случаев:

1. Как текст внутри `JSX` тега:  `<h1>{name}'s To Do List</h1>`;
2. Как значение атрибута, которое идет за символом равно. `src={avatar}` передаст через `src` значение переменной `avatar`, а `src="{avatar}"` передаст через `src` строку `"{avatar}"`.

Также можно встретить двойные фигурные скобки, они используются для атрибута `style`, так как тот принимает объект.

```js
<div 
  style={{
    backgroundColor: 'black',
    color: 'pink',
  }}>
</div>
```
#### Правила `JSX`

1. Возвращать только один элемент-родитель. Если нужно вернуть несколько, то их нужно обернуть в тег, также можно использовать `Fragment`, так как он не отображается в `DOM`;
2. Закрывать все теги. Для одиночных тегов типа `img` использовать формат `<img />`, а для парных тегов типа `div` использовать формат `<div></div>`;
3. Использовать `camelCase` для всех атрибутов (кроме `aria-*` и `data-*`). Некоторые атрибуты зарезервированы как ключевые слова в `JSX`, например, `class` и `for`, поэтому для них есть другие названия, например, `className` и `htmlFor`.

### `React` Дерево

Из `React` элементов и компонентов строится дерево. Это не `DOM дерево`, потому что `React` не работает напрямую c `DOM`. Он работает с `Virtual DOM`.

### Жизненный цикл компонентов

- `Mount` - первый рендер компонента;
- `Update` - обновление состояния компонента (перерендер);
- `Unmount` - удаление компонента.

### `Props`

`Props` - объекты, в котором заключены данные, которое компонент, стоящий в [[Базовый#`React` Дерево|дереве]] выше, передает данные компоненту, стоящему в [[Базовый#`React` Дерево|дереве]] ниже. 

> Даже если в компонент ничего не было передано, то у него все равно будут `props`.

Предположим, что у нас есть компонент `FilmDetails`, который является ребенком компонента `App` и мы хотим в `FilmDetails` передать `пропсы`. Мы передаем их как значения атрибутов у `HTML-тегов`.

#### Передача пропсов

- Нужно передавать константное значение (строка или булеан):
    - Для передачи строки используется формат `attribute="value"`
    - Для передачи булеан, а именно значение `true` используется формат `attribute`, а если нужно `false`, то просто не указываем атрибут;
- Нужно передать динамическое значение используем синтаксис `attribute={something.good}`, что указывается в таких скобках является `JS` кодом, который будет выполнен. Таким же образом передаются и остальные примитивы, кроме строки и булеана.

```js
const App = () => {
  return (
    <FilmDetails
      title="title"
      seasonsCount={data.seasondCount}
      isWatched
    />
  )  
}
```

Помимо атрибутов внутрь компонента можно передавать и компоненты и/или элементы.

```js
const App = () => {
  return (
    <FilmDetails>
      <div>Hello</div>
    </FilmDetails>
  )  
}
```

#### Принятие пропсов

В компоненте-ребенке можно использовать деструктуризацию, чтобы вытянуть свойство из пропсов. Также благодаря этому синтаксису можно использовать:

- Присвоение свойству значения по умолчанию `({ title = 'Unknown' })`;
- Сбор свойств в отдельную переменную `({ ...other})` (хотя это обычно не практикуется).

```js
const FilmDetails = ({ title, seasonsCount, isWatched }) => {
  return (
    <div></div>
  )
}
```

Если в компонент был передан другой компонент и/или элемент, то к нему можно получить доступ через свойство `children`, которое также является частью `props`.

```js
const FilmDetails = ({ children }) => {
  return (
    <div>{children}</div>
  )
}
```

> Пропсы являются неизменяемыми, если приходящее значение нужно изменить, то это делается по-другому.
### Условный рендеринг

В `React` можно рендерить `JSX` по условию при помощи `if`, `&&` и тернарного оператора `? :`.

#### Использование `if`

Так можно возвращать из компонента разный `JSX` с использованием `if`:

```js
const Item = ({ isPacked }) => {
  if (isPacked) {
    return <li className="item">{name} ✔</li>;
  }
  return <li className="item">{name}</li>;
}
```

Ниже будет указано, как можно использовать тернарный оператор, чтобы сделать это проще.

#### Возвращение `null` по условию

Можно вернуть из компонента `null`, если нужно, чтобы элементы внутри него не были отрендерены:

```js
const Item = ({ isPacked }) => {
  if (isPacked) {
    return null;
  }
  return <li className="item">{name}</li>;
}
```

На практике же использование `null` внутри компонента встречается редко. Чаще всего условием рендеринга компонента управляет родитель. Распространённым вариантом является использование оператора `&&` или `? :`.

#### Использование `&&`

Запись формата `{condition && <A />}` отображает либо `<A />`, если `condition === true`, либо ничего, если `condition === false`. Это работает, потому что оператор `&&` возвращает первое значение, которое может быть преобразовано в `false` или последнее значение.

```js
const App = () => {
  const isPacked = true;

  return {isPacked && <Item />}
}
```

> Не нужно использовать этот оператор с числами. К примеру, выражение `messageCount && <p>New messages</p>`, когда `messageCount` будет равно `0`, то так как `Boolean(0) === false`, то `React` отобразит `0`, вместо этого лучше использовать `Boolean(messageCount) && <p>New messages</p>` или `messageCount > 0 && <p>New messages</p>`.

> Поэтому условие при операторе `&&` должно возвращать либо `false`, либо `true`.

При помощи этого оператора можно переписать [[Базовый#Использование `if`|этот пример]]:

```js
const Item = ({ isPacked }) => {
  return <li className="item">{name} {isPacked && ' ✔'}</li>
}
```

#### Использование `? :`

Запись формата `{condition ? <A /> : <B />}` отображает либо `<A />`, если `condition === true`, либо `<B />`, если `condition === false`.

```js
const App = () => {
  const isPacked = true;

  return {isPacked ? <Item1 /> : <Item2 />}
}
```

При помощи этого оператора можно переписать [[Базовый#Использование `if`|этот пример]]:

```js
const Item = ({ isPacked }) => {
  return <li className="item">{isPacked ? name + ' ✔' : name}</li>;
}
```

### Чистые компоненты

Компоненты в `React` должны быть выполнены в качестве чистых функций, то есть тех функций, который:

1. На одни и те же входящие значения возвращать одни и те же выходящие значения;
2. Не содержать внутри себя `сайд-эффекты`.

Если придерживаться такого подхода, то тестировать такие компоненты намного проще, так как они ничего не изменяют извне. Также такие компоненты можно кэшировать, потому что на одни те же входящие значения, возвращаются одни и те же выходящие, что приведет к улучшению производительности.

Неизменность `пропсов` исходит из концепции "чистого компонента. Этот подход распространяется не только на `пропсы`, но и на `state` и `context`.

#### Сайд-эффекты

В React к `сайд эффектам` относятся операции или поведение, которые происходит в компоненте во время рендеринга и не влияют напрямую на текущий цикл рендеринга компонента. Эти побочные эффекты могут включать в себя такие задачи, как получение данных, подписки, ручное изменение DOM или другие взаимодействия с внешним миром.

Такие операции обычно размещаются в `обработчики событий` или `useEffect`, однако этот хук должен быть вашим последним средством для `сайд эффектов`. 