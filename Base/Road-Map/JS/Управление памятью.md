---
tags:
  - roadmap
refs:
  - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_management
  - https://habr.com/ru/articles/779186/
date: 2024-06-20
author: Ruslan Seit-Akaev
---
## Цикл жизни памяти

Независимо от языка программирования жизненный цикл памяти практически всегда один и тот же:

1. Выделить память нужное количество памяти;
2. Использовать эту память (чтение, запись);
3. Освободить ранее выделенную память, когда она более не нужна.

Вторая часть является явной во всех языках. Первая и последняя часть явна в языках низкого уровня, а в языках высокого уровня, таких как `JavaScript` в основном неявна.
### Выделение памяти в `JavaScript`

#### Инициализация переменных

Чтобы не беспокоить программиста выделением памяти, `JavaScript` автоматические выделяет память при первоначальном объявлении значений.

```javascript
const n = 123; // выделение памяти для числа
const s = "azerty"; // выделение памяти для строки

const o = {
  a: 1,
  b: null,
}; // выделение памяти для объекта и содержащих внутри него значений

// выделение памяти для массива
// и содержащих значений
const a = [1, null, "abra"];

function f(a) {
  return a + 2;
} // выделение память для функций (которая является вызываемым объектом)

// фунциональные выражения также выделяют память на объект
someElement.addEventListener(
  "click",
  () => {
    someElement.style.backgroundColor = "blue";
  },
  false,
);
```
#### Выделение при помощи вызовов функций

Некоторые функции при вызове приводят к выделению памяти для объекта.

```javascript
const d = new Date(); // выделить объект Date

const e = document.createElement("div"); // выделить DOM элемент
```

Некоторые методы выделяют новые значения или объекты.

```javascript
const s = "azerty";
const s2 = s.substr(0, 3); // s2 новая строка
// Так как строки это немутируемые значения, то JavaScript может решить не выделять память, а просто хранить [0, 3] диапазон

const a = ["ouais ouais", "nan nan"];
const a2 = ["generation", "nan nan"];
const a3 = a.concat(a2);
// новый массив из 4 элементов
```
### Использование значений

Использование значений означает чтение и запись из/в выделенную память. Это может быть осуществлено через чтение или запись значение из переменной или свойства объекта или даже проброс аргумента в функцию.
### Освобождение памяти, которая больше не нужна

Большой процент проблем с управлением памятью происходит на этой фазе. Самой большой трудность является факт осознания момента, когда выделенная память больше не нужна, чтобы её можно было освободить.

Низкоуровневые языки программирования вроде `C` имеют инструменты ручного управления памятью, поэтому именно программист решает, когда нужно освободить память

Высокоуровневые языки программирования, вроде `JavaScript`, используют форму автоматического управления памяти, известную как `сборка мусора`. Его целью является отслеживание распределения памяти и определять, когда блок выделенной памяти больше не нужен, затем освобождать его.

## Сборка мусора

### Ссылки

Основная концепция, на которую опираются алгоритмы сборки мусора - концепция `ссылки`. В контексте управления памятью говорят, что объект ссылается на другой объект, если первый имеет доступ ко второму (явно или неявно). К примеру, объект `JavaScrupt` имеет ссылку на свой прототип (неявная ссылка) и на значения своих свойств (явная ссылка).

Под объектом тут подразумевается не просто обычный объект `JavaScript`.
### Алгоритм сборки мусора - подсчет ссылок

В настоящее время ни один современный движок `JavaScript` не поддерживает этот алгоритм.

Это самый простой алгоритм сборки мусора. Он определяет, что объект не нужен больше, если количество ссылок, которое на него ссылается равно `0`.

Для примера:

```javascript
let x = {
  a: {
    b: 2,
  },
};
// Создаются 2 объекта. На внутренний объект ссылается внешний, так как внутренний является его свойством.
// На внешний объект также имеется ссылка, посколько он присвоен переменной "x".
// Очевидно, что ни один из них не может быть собран сборщиком мусора.

let y = x;
// Переменная "y" это вторая переменная, которая ссылается на внешний объект.

x = 1;
// Теперь на внешний объект есть ссылка только из переменной "y".

let z = y.a;
// В переменной "z" теперь лежит ссылка на свойство "a".
// Внутренний объект теперь имеет 2 ссылки, одну как свойство внешнего объекта, а вторая ссылка лежит в переменной "z".

y = "mozilla";
// На внешний объект теперь 0 ссылок, поэтому он может быть собран сборщиком мусора.
// Однако на внутренний объект все ещё ссылается переменная "z", поэтому он не может быть собран.

z = null;
// Теперь на внутренний объект также никто не ссылается, поэтому он может быть собран.
```

Существует ограничение на `циклические ссылки`. Ниже создаются два объекта со свойствами, которые ссылаются друг на друга, создавая таким образом цикл. К ним нельзя будет получить доступ после завершения вызова функции, поэтому они становятся ненужными, и выделенная им память должна быть освобождена. Однако алгоритм подсчета ссылок не будет считать их пригодными для сборки, поскольку каждый из двух объектов имеет хотя бы одну ссылку, указывающую на них, в результате чего ни один из них не будет помечен для сборки мусора. Циклические ссылки являются распространенной причиной утечек памяти.

```javascript
function f() {
  const x = {};
  const y = {};
  x.a = y; // x ссылается на y, так как y является его свойством
  y.a = x; // y ссылается на x, так как x является его свойством

  return "azerty";
}

f();
```
### Алгоритм сборки мусора - маркировка и очистка

Этот алгоритм определяет, что объект не нужен больше, если он является недостижимым.

Здесь вводится концепция `объект-корень`. В `JavaScript` таким объектом является глобальный объект. Периодически сборщик мусора стартует с этих корней, находит все объекты, на которые ссылаются эти корни, затем все объекты, на которые ссылаются эти объекты (`root -> object1 -> object2 -> ...`) и т.д. Таким образом, начиная с корней, сборщик мусора находит все доступные объекты и собирает все недоступные объекты.

Этот алгоритм является улучшением предыдущего, поскольку объект, имеющий нулевые ссылки, фактические недостижим. Обратное неверно, как видно на примере `циклических ссылок`.

В настоящее время все современные движки оснащены сборщиком мусора с этим алгоритмом. Все улучшения, сделанные в области сборки мусора JavaScript (`поколенческая`/`инкрементная`/`параллельная`/`параллельная сборка мусора`) за последние несколько лет, являются улучшениями реализации этого алгоритма, но не улучшениями по сравнению с самим алгоритмом сборки мусора или его сокращением определения того, когда «объект больше не нужен».

Непосредственным преимуществом этого подхода является то, что `циклические ссылки` больше не являются проблемой. В первом примере выше, после возврата вызова функции, на эти два объекта больше не ссылается какой-либо ресурс, доступный из глобального объекта. Следовательно, сборщик мусора обнаружит их недоступными, и выделенная им память будет освобождена.

Однако возможность вручную контролировать сбор мусора остается. Бывают случаи, когда было бы удобно вручную решить, когда и какая память освобождается, чтобы этого достичь, нужно объект сделать недосягаемым. Также невозможно программно запустить сборку мусора в `JavaScript`.

Доступ из глобального объекта осуществляется через лексическое окружение, замыкания и глобальный объект `root`, к которому доступа нет.

## Структуры данных, помогающие управлять памятью

TODO: Написать про `WeakMap`, `WeakSet`, `WeakRef` и `FinalizationRegistry`

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_management#data_structures_aiding_memory_management