## Что это?

В `TS` `declare` это ключевое слово, использующееся для объявление сущностей, которые есть, но не реализованы в коде. Это помогает `TS` понять, что такие сущности вообще присутствуют и не генерировать ошибку, когда к ним пытаются обратиться.

Если говорить иначе, то использование `declare` позволяет описать `API`, будь то функция, переменная, модуль и т.д., а реализация пишется отдельно.

---
## Когда это может быть полезно?

>`declare` это скорее костыль, нежели хорошая практика, и если всё делать по уму, можно обойтись и без него, но некоторые сценарии принуждают к использованию `declare`.

### Глобальные переменные

В современной разработке редко когда используют глобальные переменные, но есть исключения:

- **Старые проекты**. Например, проект на чистом JS, который начали переписывать на TS. В нём могут быть глобальные объекты вроде `window.myAppConfig`.

- **Интеграция с внешними сервисами**. Иногда сторонние SDK (например, **Google Analytics, Stripe**) добавляют глобальные переменные (`window.gtag`), и нам приходится явно описывать их типы.

Если мы обратимся в `TS` коде к такому глобальном объекту, который был объявлен в `JS` коде, то мы резонно получим ошибку, так как `TS` ничего не знает об этом глобальном объекте.

Поэтому нам явно нужно определить, что такое свойство или объект существует, а реализация лежит за пределами `TS`.

```ts
// src/global.d.ts
export {};

declare global {
  interface Window {
    myAppConfig: { userId: string };
  }
}
```

И в `tsconfig.json` указать.

```ts
// tsconfig.json
{
  "compilerOptions": {
    "types": ["./src/global.d.ts"]
  }
}
```

Теперь при обращении в коде, написанном на `TS`, ошибки не будет.

```ts
// global.ts
console.log(window.myAppConfig.userId);
```

> Такая настройка нужна только если нужно расширить встроенные объекты, используя `declare global`, что само по себе является плохой практикой.

### Работа с JS-библиотеками без типов

В реальных проектах стараются выпиливать библиотеки, которые написаны на чистом `JS`, либо же их обновлять до той версии, где авторы переписали их на `TS`, но есть исключения:

- **Закрытые (внутренние) библиотеки**. В проекте может использоваться библиотека, к кодовой базе которой у тебя нет доступа.

- **Небольшая библиотека на чистом JS**. Некоторые маленькие библиотеки, размещённые на `NPM`, написаны на чистом `JS` и авторы могут просто не переписать её на `TS`.

- **Библиотека устарела и не поддерживается больше**. На проекта используется `deprecated` библиотека, но нет времени, чтобы её выпилить.

Если мы обратимся к методу, про который не знает `TS`, но он существует в либе на `JS`, то мы также получим ошибку, поэтому можно использовать `declare`, чтобы избежать этого.

Например есть либа `math-lib` в `node_modules`, написанная на чистом `JS`, и у неё есть функция `sum` и мы хотим эту функцию юзать в `TS`. 

```ts
// math-lib.d.ts
export declare function sum(a: number, b: number): number;
```

Теперь ошибки не будет.

```ts
// math-lib.js
import { sum } from "./math-lib";

console.log(sum(2, 3));
```

### Расширение стандартных объектов

Этот пункт вытекает из двух предыдущих, если нужно расширить стандартные объекты, например создать новый метод у `Array.prototype`.

```ts
// src/array-extensions.d.ts
export {};

declare global {
  interface Array<T> {
    last(): T | undefined;
  }
}
```

И в `tsconfig.json` указать.

```ts
// tsconfig.json
{
  "compilerOptions": {
    "types": ["./src/array-extensions.d.ts"]
  }
}
```

Теперь при обращении в коде, написанном на `TS`, ошибки не будет.

```ts
// test.ts
const lastItem = [1, 2, 3].last();
```

Но это также не является хорошей практикой, так как `TS` не контролирует реализацию, можно забыть добавить реализацию `last`, и `TS` не выкинет ошибку, а код при запуске упадёт, поэтому лучше использовать утилитарные функции на месте.

---
## Итог

Работа с `declare` в современной разработке может использоваться как вынужденная мера в легаси проектах, в остальных случаях лучше использовать чистый `TS`.