## Метод, не подходящий для перебора типа массива

### При помощи `T[number]`

`T[number]`, применённый к массиву возвращает объединение.

```ts
type A = [1, "2", true, null][number]; // true | 1 | "2" | null
```

Для перебора массива он не подходит, потому что нельзя выделить один элемент. Поэтому у у него всего несколько способ применения:

1. Вернуть объединение из массива;
2. Проверить элемент на принадлежность массива, причём проверка может быть только нестрогой, так как некоторые типы в объединении при использовании [[Conditional types (условные типы)#Distributive conditional types (распределительные условных типов)|распределение типа]] могут [[Easy#Типы, которые могут распадаться на более простые|распадаться]] на более простые, такая проверка не подойдёт для [[includes]]

## Методы, подходящие для перебора типа массива

Способы расположены по степени мощности от менее мощных до тех, что дают полный контроль.

### При помощи `mapped object types`

В отличие от [[Mapped object types (перебор типа объект)|перебор объекта]], который может использовать на объекте, чтобы удалять или изменять элементы, перебор для массива может только изменять элементы. Это происходит из-за того, что в конструкции ниже, `K` обязательно должен быть индексом массива, что структура массива могла сохраниться, 

```ts
{ [K in keyof T]: ... }
```

А запись с использованием `as`. Хоть и сохраняет в `Key` индекс массива, а в `ArrayType[Key]` элемент массива, но разрушает структуру массива и на выходе мы получаем объект, это происходит из-за удаление индексов.

```ts
type MappedIterate<ArrayType extends unknown[]> = {
  [Key in keyof ArrayType as ArrayType[Key] extends 1 ? never : Key]: ArrayType[Key];
}

type A = MappedIterate<[1, 2, 3, 4]> // { [x: number]: 2 | 1 | 4 | 3; length: 4;  toString: () => string; }
```

Поэтому единственное, для чего подойдёт использование этого метода, это изменение элементов массива с сохранением его длины (аналог `Array.prototype.map`), так как там мы не удаляем индексы.

К примеру, ниже дженерик ниже, заменяет числа на строки.

```ts
type MappedIterate<ArrayType extends unknown[]> = {
    [Key in keyof ArrayType]: ArrayType[Key] extends number ? `${ArrayType[Key]}` : never
}

type A = MappedIterate<[1, 2, 3, 4]> // ["1", "2", "3", "4"]
```

### При помощи `infer`

Единственный способ, который позволяет в полной мере управлять элементами в массиве.

Например дженериком ниже можно превратить массив в объединение, имитируя использование `T[number]`.

```ts
type ArrayToUnion<ArrayType extends unknown[]> = ArrayType extends [infer FirstItem, ...infer Rest]
    ? FirstItem | ArrayToUnion<Rest>
    : never;

type A = ArrayToUnion<[1, 2, 3, 4]>; // 1 | 2 | 3 | 4
type B = ArrayToUnion<[]>; // never
type C = ArrayToUnion<[1, "d", {}, null]>; // {} | 1 | "d" | null
```

Также при помощи этого способа легко получать и удалять первый/последний элемент в массиве:

- [[pop]]
- [[last]]
